\documentclass[a4paper, 11pt, oneside]{report} 
\usepackage[utf8]{inputenc}
\usepackage[dutch]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{caption}
\usepackage[table,xcdraw]{xcolor}
\usepackage[toc,page]{appendix}
\usepackage{hyperref}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{trees}
\usepackage{tikz-qtree}
\usepackage{graphicx}
\usepackage{fancyref}
\usepackage{wrapfig}
\usepackage{url}
\usepackage{pdflscape}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
\graphicspath{ {Afbeeldingen/} }
\usepackage{subfig}
\usepackage{tabularx}
\usepackage{apacite}
\usepackage{longtable}
\usepackage{titlecaps}
%\usepackage[T1]{fontenc}
\usepackage{titlesec, blindtext, color}
\definecolor{gray75}{gray}{0.75}
\newcommand{\hsp}{\hspace{20pt}}
\usepackage{pdfpages}
\usepackage{afterpage}


\newcolumntype{L}[1]{>{\raggedright\arraybackslash}p{#1}}

\titleformat{\chapter}[hang]{\huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Large\bfseries}

\def\figureautorefname{Figuur}
\def\sectionautorefname{Paragraaf}
\def\chapterautorefname{Hoofdstuk}
\def\tableautorefname{Tabel}
\DeclareRobustCommand{\VAN}[3]{#2} % set up for citation

\lstset { %
	language=C++,
	backgroundcolor=\color{black!3}, % set backgroundcolor
	basicstyle=\footnotesize,% basic font setting
}

%% Sets page size and margins 
\usepackage[a4paper,top=3cm,bottom=3cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\author{M.W.J. Berentsen}
\font\myfont=cmr12 at 40pt
\title{\myfont Drone meshnetwerk simulatie}
\usepackage{titling}

\newcommand{\subtitle}[8]{%
	\posttitle{%
		\par\end{center}
	\begin{center}\large#1\end{center}
	\vskip0.5em
	\begin{center}\large#2\end{center}
	\begin{center}\large#3\end{center}
	\begin{center}\large#4\end{center}
	\begin{center}\large#5\end{center}
	\begin{center}\large#6\end{center}
	\begin{center}\large#7\end{center}
	\begin{center}\large#8\end{center}
	\vskip0.5em}%
}

\subtitle{Software Design Document}{HAN Arnhem}{561399}{MWJ.Berentsen@student.han.nl}{Versie 1}{Alten Nederland B.V.}{Docent: J. Visch, MSc}{Assessor: ir. C.G.R. van Uffelen}

\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 2pt minus 1pt}



\hypersetup{colorlinks=true, urlcolor=red,citecolor=black,linkcolor=blue}  % Colours hyperlinks in blue, but this can be distracting if there are many links.
\setcounter{tocdepth}{2}



\begin{document}
\begin{figure}
	\begin{center}\includegraphics[scale=0.1]{alten}\end{center}
\end{figure}
\maketitle

%\section*{Voorwoord}
%\addcontentsline{toc}{section}{\protect\numberline{}Voorwoord}
%\pagebreak

%Geschikt voor minimaal 50 nodes; Kan slecht of geen signaal nabootsen

\tableofcontents
\clearpage


%\clearpage

%\section*{Samenvatting}
%\addcontentsline{toc}{section}{\protect\numberline{}Samenvatting}
%\pagebreak


\chapter{Inleiding}
\label{inleiding}
Het volgende verslag betreft de Software Requirements Specification voor de afstudeerstage van Maurice Berentsen (hierna: student).
Dit document volgt het document: \textit{"Software Design Description Template"} \cite{template:sdd}

Het beschrijft de hoe de uiteindelijke applicatie eruit zal zien en wat de functionaliteit hiervan zal zijn. Op de manier is het voor de student maar ook betrokken partijen duidelijk wat er gerealiseerd zal worden. Het verduidelijk de werking van de sub-componenten en de onderlinge relaties. 

\subsection{leeswijzer}
\label{inleiding:beschrijving:leeswijzer}
Eerst zal een korte beschrijving gegeven worden van het doel van dit document.Daarna wordt er door middel van een tabel een begrippenlijst toegelicht. In het tweede hoofdstuk is als eerste een component diagram te vinden waarin de functionaliteit van de verschillende componenten te vinden is en de manier waarop deze componenten met elkaar communiceren. Vervolgens is de algemene flow van het programma te zien, hierin wordt duidelijk welke stappen er onder water worden genomen als er een bepaalde actie wordt uitgevoerd. In hoofdstuk drie worden alle subsystemen duidelijk uitgewerkt en worden de ontwerpen van deze systemen uitgewerkt. 
\section{Begrippenlijst}
\label{inleiding:begrippenlijst}

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[H]
\centering

\label{begrippen}
\begin{tabular}{|l|l|}
\hline
\rowcolor[HTML]{C0C0C0}
Term        & Omschrijving                                                         \\ \hline
term        & Omschrijving                                                      	\\ \hline

\end{tabular}
\caption{Begrippenlijst}
\end{table}

\chapter{Architectural Overview}
\label{architectural}
In het component diagram \autoref{fig:componentdiagram} op de volgende pagina is te zien dat bepaalde componenten voorzien zijn van een andere kleur. 
De groene kleur betekend dat het component voorzien is door gazebo.
De rode en blauw kleur zijn gegeneerd door ROS waarbij de rode een rosservice zijn en de blauwe een rostopic.
Op het hoogste niveau is het diagram te verdelen in vier groepen.

\textbf{Communication} is het component die de beslissingen neemt voor de communicatie.
Het heeft de intelligentie om het netwerk in kaart te brengen en te routeren.
Daarnaast is het in staat om een beslissing te nemen om een verzoek te sturen om de drone te verplaatsen.
Tenslotte bevat het meerdere berichten die gebruikt om het netwerk te kunnen onderhouden en op te bouwen.    

\textbf{Drone} is op dit moment een leeg component waar alleen een high level interface aanwezig is die de mogelijkheid biedt om de huidige locatie van een drone terug te geven of een nieuwe locatie als doel te geven aan de drone. 

\textbf{Gazebo} is de plek waar de virtualisatie van de drone plaats vindt.
Er kunnen virtuele router of gateway drones gemaakt worden die voorzien zijn van een virtuele arduino ingeladen met de juiste software en een virtuele drone motor.
Deze worden als model plug-in gekoppeld aan de drone in een gesimuleerde wereld waar Gazebo vervolgens physics op de drones kan uitvoeren. 

\textbf{ROS} is het component waar de simulatie van de communicatie plaats vindt.
Er is een virtuele NRF24 om te communiceren met andere nodes in het netwerk.
De aanwezige WirelessSignalSimulator zorgt dat dit realistisch gebeurd door alleen communicatie uit te voeren als dit volgens de voorwaarden mag.
Dit bepaald de simulator op basis van informatie die het krijgt van Gazebo en de NRF.
Tenslotte is er een DroneManager aanwezig die een interface aanbiedt via ros voor de ontwikkelaar om verbinding te maken met de gateways uit het netwerk.

\textbf{Arduino} is het component die zich onderscheid in twee rollen, een Arduino kan de rol van gateway hebben of de rol van router in de het meshnetwerk.

\textbf{NRF24} is het gebruikte component om draadloze communicatie mogelijk te maken. Het is voorzien van een driver in de vorm van een low level interface en bied zich aan via een high level interface voor communicatie.

Na het component diagram zal elke subcomponent kort toegelicht worden


\begin{landscape}
	\begin{figure}[p]%
		\includegraphics[width=\linewidth]{Afbeeldingen/ComponentDiagram.png}%
		\caption{Globale component diagram}
			\label{fig:componentdiagram}
	\end{figure}%
\clearpage
\end{landscape}
\clearpage


\section{Interfaces}
\label{architectural:interfaces}
\subsection{IInternetConnection}
\label{architectural:interfaces:IInternetConnection}
Deze high level interface wordt gebruikt voor het leggen van een verbinding naar een extern punt buiten het netwerk. Omdat de gateway zich alleen hoeft te verbinden met een punt bestaat deze interface alleen uit een connect en een disconnect.
\subsection{IGatewayCommands}
\label{architectural:interfaces:IGatewayCommands}
Deze interface wordt gebruikt voor het ontvangen van commando's via een verbinding met een extern punt buiten het netwerk. Op dit moment is er alleen een functie aanwezig voor het verzoeken van een drone verplaatsing
\subsection{IWirelessCommunication}
\label{architectural:interfaces:IWirelessCommunication}
In deze interface wordt de functionaliteit gesteld waar een draadloos communicatiemiddel aan moet voldoen. Het bevat functies om een antenne te starten en te stoppen. Het versturen van een bericht naar een specifiek punt of het zenden naar elke punt in de buurt. Er is een functie aanwezig om wanneer mogelijk debugging te gebruiken. Tenslotte moet een aansluitend component met deze interface moeten kunnen teruggeven of deze aan of uit staat.

\subsection{IMeshNetwork}
\label{architectural:interfaces:IMeshNetwork}
Deze interface wordt aangeboden om een aangesloten draadloos communicatie middel de mogelijkheid te geven om berichten door te kunnen geven aan het \nameref{architectural:subcomponenten:MeshnetworkComponent} en het ID van dit component kenbaar te maken.

\subsection{IMeshDebugInfo}
\label{architectural:interfaces:IMeshDebugInfo}
Deze interface wordt aangeboden om een verzameling variabelen openbaar te maken die nuttig zijn als debug informatie.

\subsection{NRF24HighLevelInterface}
\label{architectural:interfaces:NRF24HighLevelInterface}

Deze high level interface is de aangeboden interface van de NRF24 en voldoet aan de interface \nameref{architectural:interfaces:IWirelessCommunication}. Het praat direct met de driver van de NRF24.  

\subsection{NRF24LowLevelInterface}
\label{architectural:interfaces:NRF24LowLevelInterface}
Deze low level interface is de driver van de NRF24


\subsection{IDroneEngine}
\label{architectural:interfaces:IDroneEngine}
Een drone engine interface representeert de aansluiting met een drone.
Hierin moet het mogelijk zijn om een doel coördinaat te sturen naar de drone om zich naartoe te verplaatsen. 
Daarnaast moet het mogelijk zijn voor een drone om de huidige positie terug te geven.
\subsection{IRoutingTechnique}
\label{architectural:interfaces:IRoutingTechnique}
Deze interface bevat functies voor het uitvoeren van een routeringstechniek.
Het heeft functies voor het starten en onderhouden van het netwerk.
Daarnaast zijn er functies hoe gereageerd moet worden op het vinden en verliezen van andere netwerkpunten.
Er zijn functies aanwezig om een adres op te halen waar naartoe gezonden moet worden om een punt te bereiken.
Ook kan er opgehaald worden welke punten zijn aangesloten, hoeveel punten dit zijn en hoeveel directe aansluitingen er zijn.
Tenslotte is er functie aanwezig die aangeroepen wordt zodra een drone zich verplaatst zodat hier adequaat op gereageerd kan worden.

\section{Ros topics en services}
\label{architectural:ros}
Zoals al eerder benoemd wordt er gebruik gemaakt van de transportlaag van ROS. Dit wordt gedaan in de vorm van Ros topics en services. Hieronder worden de messages en services kort toegelicht.
%ROS SERVICES
\subsection{RequestGatewayDroneFlight}
\label{architectural:ros:service:RequestGatewayDroneFlight}
Via deze aangeboden service is het mogelijk om een verzoek te sturen naar de gateway voor een verplaatsing. In het verzoek moet het nodeID en locatie zitten.


\subsection{CasusRequest}
\label{architectural:ros:service:CasusRequest}
Deze service maakt het mogelijk om een casus posities door te sturen naar de drones.

\subsection{PowerSwitch}
\label{architectural:ros:service:PowerSwitch}
Via deze simpele service kan een \nameref{architectural:subcomponenten:VirtualNRF24} aan of uit gezet worden.

\subsection{WirelessMessageRequest}
\label{architectural:ros:service:WirelessMessageRequest}
De \nameref{architectural:subcomponenten:VirtualNRF24} gebruikt deze service om een NRF24 bericht te versturen naar een andere NRF24. De response geeft aan of het zenden lukte.

\subsection{AreaScanRequest}
\label{architectural:ros:service:AreaScanRequest}
Deze service kan aangeroepen worden om de id's van alle nodes binnen het bereik van een node terug te krijgen. 
Dit is nodig om een algemene zending naar iedereen binnen bereik mogelijk te maken.

\subsection{RequestGPS}
\label{architectural:ros:service:RequestGPS}
Deze service wordt aangeboden door de \nameref{architectural:subcomponenten:DroneEngine} en biedt de mogelijkheid om de huidige locatie van een drone op te vragen. 

%ROS TOPICS
\subsection{RequestGatewayDroneFlight}
\label{architectural:ros:topic:RequestGatewayDroneFlight}
Dit topic wordt gebruikt om locatieverplaatsingverzoeken op te publiceren. 

\subsection{NodeDebugInfo}
\label{architectural:ros:topic:NodeDebugInfo}
Elke \nameref{architectural:subcomponenten:VirtualNRF24} maakt wanneer dit verzocht wordt een Debug topic aan. Hierop wordt informatie gepubliceerd wat van toegevoegde waarde is voor ontwikkelaars.

\subsection{NRF24}
\label{architectural:ros:topic:NRF24}
Een \nameref{architectural:subcomponenten:VirtualNRF24} luistert naar dit topic om zo berichten te kunnen ontvangen.

\subsection{Location}
\label{architectural:ros:topic:Location}
Het location topic representeert de verbinding die een \nameref{architectural:subcomponenten:MeshnetworkComponent} zou hebben met een drone op doelen op te versturen waar de Drone heen moet vliegen. 

\subsection{DroneInfo}
\label{architectural:ros:topic:DroneInfo}
Dit topic is essentieel voor de \nameref{architectural:subcomponenten:WirelessSignalSimulator}. De informatie die hierop gepubliceerd wordt omvat informatie over de locatie van een \nameref{architectural:subcomponenten:VirtualNRF24} of die aan staat en naar welk \nameref{architectural:ros:topic:NRF24} topic deze luistert.

\chapter{Detailed Design Description}
\label{DetailedDesign}

\section{Deployment Diagram}
\label{DetailedDesign:deployment}
In dit deployment diagram staan de executables (ROS nodes) die opgestart worden door de verschillende launch files, daarnaast zijn ook de twee ino files meegenomen die gebruikt worden bij de drones

\begin{figure}[H]
	\begin{center}\includegraphics[width=\linewidth]{UML/out/DeploymentDiagram/DeploymentDiagram/DeploymentDiagram.png}\end{center}
	\caption{deployment diagram drone meshnetwerk}
	\label{fig:deploymentdiagram}
\end{figure}

\subsection{Ontwerpkeuzes met betrekking tot deployment}
\label{DetailedDesign:deployment:decisisions}

\subsubsection{Geen aangeboden mogelijkheid om drones los op te starten}
Er is voor gekozen om alleen via het factory.launch bestand de drones te kunnen starten. 
De factory.launch moet gebruikt worden omdat deze factory.world aanroept welke op zijn beurt de plugin start die de drones aanmaakt.  
In factory.world is het configureerbaar hoeveel gateway en router drones aangemaakt moeten worden.
Deze keuze is gemaakt omdat elke drone een uniek id moet hebben in de simulatie omdat elke motor zijn aansluiting publiceert aan de hand van dit id.

Om de gebruiker ervan te ontmoedigen is er daarom ook geen SDF bestand aanwezig waarmee normaal objecten in gazebo geladen worden. 

\section{Design Sub-Systeem Communicatie}
Het sub-systeem communicatie is verantwoordelijk voor de communicatie door het gebruik van mesh technologie.
Het subsysteem kan dit niet alleen en werkt daarom samen met andere subsystemen, welke zichtbaar zijn in het  \nameref{fig:componentdiagram}.
Het component communicatie bestaat ook weer uit kleinere componenten welke weergeven staan in het \nameref{fig:component:Communicatie}
  
\label{DetailedDesign:Communicatie}
\subsection{Component Diagram}
\label{DetailedDesign:CommunicatieComponentDiagram}
In de onderstaande afbeelding \ref{fig:component:Communicatie} staat het component diagram van de communicatie weergeven.
Het is een extractie uit het \nameref{fig:componentdiagram} 
\begin{figure}[H]
	\begin{center}\includegraphics[width=\linewidth]{Afbeeldingen/CommunicationComponentDiagram.png}\end{center}
	\caption{Component diagram communicatie}
	\label{fig:component:Communicatie}
\end{figure}


\subsubsection{Meshnetwork}
\label{architectural:subcomponenten:Meshnetwork}
Dit component bevat de basis componenten voor het opbouwen van een meshnetwerk.

\subsubsection{MeshnetworkComponent}

\label{architectural:subcomponenten:MeshnetworkComponent}
Een MeshnetworkComponent is de basis van elk component in het mesh netwerk.
Het vereist routeringstechniek via de \nameref{architectural:interfaces:IRoutingTechnique}, een aansluiting naar een drone via \nameref{architectural:interfaces:IDroneEngine} en een vorm van draadloze communicatie via \nameref{architectural:interfaces:IWirelessCommunication}.
Hij maakt gebruikt van het component \nameref{architectural:subcomponenten:Messages} om te communiceren met andere MeshnetworkComponenten.

\subsubsection{MeshnetworkRouter}
\label{architectural:subcomponenten:MeshnetworkRouter}
Een meshnetwork router is een \nameref{architectural:subcomponenten:MeshnetworkComponent} die in staat is verbinding met andere nodes op te bouwen.
Zijn doel is om altijd verbinding te hebben met een \nameref{architectural:subcomponenten:MeshnetworkGateway}.
Als hij dit te lang niet heeft kan hij zich verplaatsen door aanspraak te maken op de DroneEngine.
Wanneer hij zich in een groep van andere Routers bevind zal hij eerst onderling onderhandelen wie er zich moet verplaatsen.

\subsubsection{MeshnetworkGateway}
\label{architectural:subcomponenten:MeshnetworkGateway}
De gateway is een \nameref{architectural:subcomponenten:MeshnetworkComponent} die in staat is een verbinding op te bouwen naar een punt buiten het meshnetwerk. In de huidige situatie kan dit via een internetverbinding die loopt via de interface \nameref{architectural:interfaces:IInternetConnection}. 

\subsubsection{Internet}
\label{architectural:subcomponenten:Internet}
Dit component bevat een high level interface om verbinding te maken en te verbreken met het internet.
Daarnaast biedt het een interface aan om berichten te ontvangen.

\subsubsection{Messages}
\label{architectural:subcomponenten:Messages}
Dit component betreft een verzameling van bericht samenstellingen die gebruikt worden voor de communicatie van het meshnetwerk.

\subsubsection{Message}
\label{architectural:subcomponenten:Message}
Een Message is de basis van elke bericht en bevat tenminste de volgende informatie:  Maker, zender, berichttype, ontvanger, geadresseerde. 
\subsubsection{GoToLocationMessage}
\label{architectural:subcomponenten:GoToLocationMessage}
Dit bericht bevat een locatie waar een drone zich naartoe moet verplaatsen.

\subsubsection{HeartbeatMessage}
\label{architectural:subcomponenten:HeartbeatMessage}
Dit bericht wordt gebruikt om de verbinding met anderen te onderhouden. Dit bericht maakt een hop per keer dat deze doorgestuurd wordt.

\subsubsection{IntroduceMessage}
\label{architectural:subcomponenten:IntroduceMessage}
Een introductie bericht wordt gebruikt door een node om schik voor te stellen aan alle andere nodes die dichtbij zijn. 

\subsubsection{LocationMessage}
\label{architectural:subcomponenten:LocationMessage}
Dit bericht wordt gebruikt om de huidige locatie van een node door te sturen naar een ander.

\subsubsection{MissingMessage}
\label{architectural:subcomponenten:MissingMessage}
Zodra een \nameref{architectural:subcomponenten:MeshnetworkComponent} de verbinding verliest met een ander gebruikt hij dit bericht om andere daarover te informeren.

\subsubsection{MovementNegotiationMessage}	
\label{architectural:subcomponenten:MovementNegotiationMessage}
Om onderling te onderhandelen tussen de nodes wie er actie moet ondernemen wordt dit bericht gebruikt.

\subsubsection{RoutingTechnique}
\label{architectural:subcomponenten:RoutingTechnique}
Dit component voorziet het meshnetwerk van een routing techniek wat dus inhoudt dat dit het component is die de communicatieroutes opbouwt naar andere punten in het netwerk.

\subsubsection{ChildTableTree}
\label{architectural:subcomponenten:ChildTableTree}
Deze techniek is een hybride meshnetwerk routing techniek waarbij een node de buren die deze heeft ziet als een kind.
Als een node een nieuw kind heeft vertelt hij dit aan zijn buren.
Omdat een node door zijn buren ook gezien wordt als kind registreren deze zijn nieuwe kind dus als kleinkind.
Hierdoor hoeft een node alleen maar te zoeken aan wie welk kind hij een bericht hoeft door te geven. 
De complexiteit van de routingtechniek neemt per stap in het netwerk af bij nodes met meerdere kinderen.
Als een drone zich verplaatst heeft wist deze het de opgebouwde geheugen van kinderen en kleinkinderen. 

\subsubsection{Wireless}
\label{architectural:subcomponenten:Wireless}
Dit component voorziet een \nameref{architectural:subcomponenten:MeshnetworkComponent} van een high level interface voor draadloze communicatie.
Als er een draadloos component wordt aangesloten moet deze hierop aangesloten worden. 
\subsection{Interfaces}
\label{DetailedDesign:CommunicatieComponentDiagram:interface}
Het communicatie component biedt zowel intern als extern interfaces aan. Deze worden hieronder omschreven.

\subsubsection{Extern aangeboden interface beschrijvingen}
\label{DetailedDesign:CommunicatieComponentDiagram:interface:extern}
Het communicatie component heeft drie extern aangeboden interfaces. De interface IMeshNetwork wordt aangeboden om berichten voor het meshnetwerk te kunnen ontvangen vanaf een aangesloten draadloos communicatie component. De interface IGatewayCommands wordt gebruikt voor het ontvangen van aansturing vanuit een extern punt naar een gateway. Tenslotte biedt het MeshnetworkComponent nog een interface aan met debuginformatie genaamd IMeshDebuginfo. Omdat deze laatste interface alleen maar getters bevat is besloten deze niet uitgebreid te behandelen.

\paragraph{IMeshNetwork}
\label{DetailedDesign:CommunicatieComponentDiagram:interface:IMeshnetwork}
De volgende functies worden aangeboden door de interface IMeshNetwork. 

\begin{lstlisting}
void OnMsg( const uint8_t* message );

const uint8_t getNodeID( ) const;
\end{lstlisting}

\subparagraph{OnMsg}
Deze functie geeft een antenne toegang tot een meshcomponent om berichten door te geven. Het bericht wordt opgegeven met een adresverwijzing tot de array waar het bericht in staat

\textbf{\textit{preconditie:}} Het meshcomponent heeft een thread gestart voor bericht afhandeling.

\textbf{\textit{postconditie:}} Het opgegeven bericht is behandeld door het meshcomponent.

\subparagraph{getNodeID}
Deze functie geeft de antenne door welk node id het meshcomponent bezit.

\textbf{\textit{preconditie:}} Het meshcomponent heeft een node id

\textbf{\textit{postconditie:}} Het id van het mehscomponent is doorgegeven.

\paragraph{IGatewayCommands }
\label{DetailedDesign:CommunicatieComponentDiagram:interface:IGatewayCommands}
De volgende functie wordt aangeboden door de interface IGatewayCommands. 

\begin{lstlisting}
void SendGoalRequestToDrone( const uint8_t ID, const float latitude,
			 const float longitude, const uint16_t height );
\end{lstlisting}

\subparagraph{SendGoalRequestToDrone}
Deze functie laat de aangesloten gateway een verzoek doen tot het verplaatsen van een drone. Er is nog geen ingebouwde functionaliteit om terug te geven of dit verzoek ook is aangekomen bij de drone. 

\textbf{\textit{preconditie:}} De gateway die het verzoek ontvangt heeft een route tot de drone die het verzoek moet ontvangen. 

\textbf{\textit{postconditie:}} De drone heeft het verzoek ontvangen en zal zich daar naartoe gaan verplaatsen

\subsubsection{Intern aangeboden interface beschrijvingen}
\label{DetailedDesign:CommunicatieComponentDiagram:interface:intern}

Intern worden er twee interfaces aangeboden. Het MeshnetworkComponent biedt een interface IRoutingEssentials aan waar basale communicatie functies in zitten om routeringstechnieken mogelijk te maken.  Ook wordt er een interface IRoutinTechnique door het subcomponent RoutingTechnique aangeboden.

\paragraph{IRoutingEssentials}

De volgende functies worden aangeboden door de interface IRoutingEssentials. 

\begin{lstlisting}

void searchOtherNodesInRange( )	

bool sendHeartbeat(uint8_t other);

\end{lstlisting}
\subparagraph{searchOtherNodesInRange}
Deze functie wordt aangeroepen om het component te verzoeken om te kijken of er andere nodes binnen bereik zijn.


\textbf{\textit{preconditie:}} Meshcomponent is voorzien van een draadloos communicatiemiddel die gestart is. 

\textbf{\textit{postconditie:}} Meshcomponent heeft een inventarisatie gemaakt van alles nodes binnen bereik. 

\subparagraph{sendHeartbeat}
Door het aanroepen van deze functie wordt er een hearbeat verzonden van het component naar een node met het opgegeven ID in de parameter.

\textbf{\textit{preconditie:}} Geadresseerde is bekend bij de routing techniek.

\textbf{\textit{postconditie:}} Routing techniek geeft terug welk adres het vervolg adres is voor het bericht.

\paragraph{IRoutingTechnique}

De volgende functies worden aangeboden door de interface IRoutingTechnique. 

\begin{lstlisting}
uint8_t getDirectionToNode( const uint8_t node );

void startRouting( );

void maintainRouting( );

void NodeMovedLocation( );

uint8_t cantCommunicateWithNode(const uint8_t node);

uint8_t OtherCantCommunicateWithNode(const uint8_t other, const uint8_t node);

void canCommunicateWithNode(const uint8_t node);

void OtherCanCommunicateWithNode(const uint8_t other, const uint8_t node);

const uint16_t getTableSize( );

const uint16_t getAmountOfChildren( );

const std::set< uint8_t > getSetOfChildren( );

const bool empty( );
\end{lstlisting}
\subparagraph{getDirectionToNode}
Deze functie is de functie waar de aanvragende interface het meeste belang bij heeft.
Deze functie verwacht een id van de geadresseerde node als parameter.
De routing techniek zal vervolgens uitzoeken naar welke node een bericht doorgegeven moet worden om het bericht aan te laten komen bij de geadresseerde.
Dit adres wordt terug gegeven als een return waarde. 

\textbf{\textit{preconditie:}} Geadresseerde is bekend bij de routing techniek.

\textbf{\textit{postconditie:}} Routing techniek geeft terug welk adres het vervolg adres is voor het bericht.

\subparagraph{startRouting}
De functie start routing wordt aangeroepen zodra de routing techniek moet beginnen met het opbouwen van communicatie routes.

\textbf{\textit{preconditie:}} Het communicatie waarover de routering gebeurd is beschikbaar

\textbf{\textit{postconditie:}} De node zich aangemeld bij andere nodes en kan adressen opslaan.

\subparagraph{maintainRouting}
Deze functie wordt herhaaldelijk aangeroepen in de software.
Het roept de routing techniek aan om een onderhoud te plegen aan de opgebouwde routing informatie.
Zo zal vaak het geval zijn dat de routing techniek controleert of de aansluitende nodes nog bestaan.

\textbf{\textit{preconditie:}} De routing techniek is gestart met routeren en heeft een lijst van beschikbare nodes.

\textbf{\textit{postconditie:}} Er is onderhoud uitgevoerd aan de lijst van beschikbare nodes.

\subparagraph{NodeMovedLocation} 
Deze functie wordt aangeroepen zodra de drone zich verplaatst heeft. Het is aan routing techniek om hier adequaat op te reageren.
In de huidige implementatie worden alle routes als ongeldig gezien waardoor de tabel geleegd wordt. 

\textbf{\textit{preconditie:}} Er is geen preconditie.

\textbf{\textit{postconditie:}} De routeringstechniek heeft de tabel bij adequaat bijgewerkt.


\subparagraph{cantCommunicateWithNode} 
Deze functie wordt aangeroepen als er geen connectie gelegd kan worden met een node. Deze functie geeft terug op hoeveel routes de node had in het netwerk. 

\textbf{\textit{preconditie:}} De node is aanwezig in de route tabel.

\textbf{\textit{postconditie:}} De route wordt verwijderd of als niet beschikbaar beschouwd.


\subparagraph{OtherCantCommunicateWithNode}
Deze functie wordt aangeroepen als een andere node aangeeft dat hij geen connectie kan maken met een node. Deze functie geeft terug op hoeveel routes de niet bereikbare node voorkomt. 

\textbf{\textit{preconditie:}} De node is aanwezig in de route tabel.

\textbf{\textit{postconditie:}} De route wordt verwijderd of als niet beschikbaar beschouwd.

\subparagraph{canCommunicateWithNode}
Zodra een node bevestiging heeft dat deze verbinding kan maken wordt deze functie aangeroepen. Als parameter wordt het adres meegegeven.

\textbf{\textit{preconditie:}} Er is bevestiging dat een node een directe verbinding heeft met een andere node.

\textbf{\textit{postconditie:}} De verbonden node wordt toegevoegd als direct route punt.
 
\subparagraph{OtherCanCommunicateWithNode}
De functie wordt aangeroepen als een andere node doorstuurt dat hij bevestiging heeft dat hij verbinding heeft met een nieuwe node in het netwerk. Als parameter wordt het adres meegegeven van zowel de node die aangeeft dat hij een verbinding heeft gevonden als het adres die hij gevonden heeft.

\textbf{\textit{preconditie:}}  Er is bevestiging dat een node een verbinding heeft met een andere node.

\textbf{\textit{postconditie:}}  De gevonden node wordt toegevoegd als route punt in het netwerk.


\subparagraph{getTableSize}
Deze functie geeft terug hoeveel routes er zich bevinden in de opgebouwde routing tabel.

\textbf{\textit{preconditie:}} Geen pre conditie.

\textbf{\textit{postconditie:}} Alle routes zijn geteld en de functie geeft dit aantal terug

\subparagraph{getAmountOfChildren}
In deze functie wordt het aantal gevonden direct aansluitende nodes geteld en terug gegeven.  

\textbf{\textit{preconditie:}}  Geen preconditie

\textbf{\textit{postconditie:}} Het aantal direct aansluitende nodes is geteld en en dit aantal is terug gegeven.

\subparagraph{getSetOfChildren}
Hier wordt een set gemaakt met id's van direct aansluitende nodes 
\textbf{\textit{preconditie:}} Geen preconditie

\textbf{\textit{postconditie:}} Er is een set met de id's van alle nodes waar een directe verbinding mee gevonden is

\subparagraph{empty}
Deze functie geeft een boolean terug welke aangeeft of de tabel leeg is.
Dit is een aparte functie omdat het scheelt in complexiteit ten opzichte van het tellen van een tabel en die vergelijken met 0.
  
\textbf{\textit{preconditie:}} Geen preconditie

\textbf{\textit{postconditie:}} Er is een check gedaan of de lijst leeg is en dit wordt terug gegeven.

\subsection{Sequence Diagrams}
\label{DetailedDesign:Communicatie:sequence}
Hier worden aan de hand van sequence diagrammen communicatie wegen omschreven die gebruikt worden tussen verschillende nodes in het netwerk.

\subsubsection{Heartbeat van router naar gateway met directe verbinding}
\label{DetailedDesign:Communicatie:sequence:heartbeatrouter->gateway}
Om duidelijk te maken hoe een bericht van een node naar een gateway komt wordt het scenario van een heartbeat uitgewerkt in een direct verbinden.
Deze weg van communicatie wordt voor alle directe berichten het zelfde uitgevoerd.
Dat maakt het overbodig om voor elk type bericht een sequence diagram uit te werken
\begin{figure}[H]
	\begin{center}\includegraphics[width=.97\linewidth]{UML/out/Communication/Sequence/RouterDirectNaarGatewayHeartbeat/RouterDirectNaarGatewayHeartbeat.png}\end{center}
	\caption{Sequence diagram van een heartbeat bericht van een router naar een gateway met een directe onderlinge verbinding.}
	\label{fig:communication:sequence:sequence:heartbeatrouter->gateway}
\end{figure}
In diagram \ref{fig:communication:sequence:sequence:heartbeatrouter->gateway} is de flow zichtbaar van een router die een heartbeat bericht verstuurd naar een gateway en daar ook weer response op krijgt.
Op het moment dat een router het bericht om een heartbeat te versturen naar de gateway zal hij dit altijd doen naar de gateway waar hij een voorkeursverbinding (prefferedGateway) mee heeft.
Hij zal aan de aangesloten routeringstechniek vragen of er een route mogelijk is naar de router een aan wie hij zijn bericht dan moet afgegeven.
In het geval van deze sequence diagram heeft de router een directe verbinding met de gateway en is in stap 4 te zien dat het teruggegeven adres 0 is het adres van de gateway.

Vervolgens maakt de router een heartbeat bericht aan die het via de \nameref{architectural:interfaces:IWirelessCommunication} interface verstuurd naar de Gateway.
De router geeft door aan de routeringstechniek in stap 10 of 11 of het zenden wel of niet gelukt is op basis van de succes feedback uit stap 9.
Als het niet lukt geeft hij dit ook door aan zijn aangesloten punten in stap 12. 
De werking hiervan is terug te vinden in \nameref{DetailedDesign:Communicatie:sequence:contactverlies}
Als laatste voordat de router zijn functie verlaat zet hij in stap 13 de boolean die bijhoudt of verbinding is met de gateway (connectedToGateway) op false omdat hij verwacht dat er reactie komt van de gateway die het weer op true zet.

Bij stap 8 is het gelukt om het bericht te versturen naar de gateway die daar via zijn eigen \nameref{architectural:interfaces:IWirelessCommunication} interface het bericht ontvangt.
Er is voor gekozen om deze interface maar één keer weer te geven in de tabel om het overzichtelijk te houden.
De reactie van een gateway op een heartbeat is altijd dat er een heartbeat wordt teruggestuurd naar de zender. 
De functie SendHeartbeat(uint8\textunderscore t) in stap 15 werkt gelijk aan die van stap 2 en is daarom niet opnieuw uitgewerkt.

Stap 17 is het moment dat de router weer response heeft van de gateway.
Hij stelt op basis van de inhoud van het bericht het ID van de gateway in als prefferedGateway, zet de boolean connectedToGateway weer op true en registreert hoeveel hops het bericht nodig had om aan te komen.

\subsubsection{Heartbeat van gateway naar een router via een andere router}
\label{DetailedDesign:Communicatie:sequence:heartbeatgateway->router->router}

\begin{figure}[H]
	\begin{center}\includegraphics[width=\linewidth]{UML/out/Communication/Sequence/ForwardHeartbeat/ForwardHeartbeat.png}\end{center}
	\caption{Sequence diagram van een heartbeat bericht van een gateway naar een router via een andere router.}
	\label{fig:communication:sequence:sequence:heartbeatgateway->router->router}
\end{figure}
Diagram \ref{fig:communication:sequence:sequence:heartbeatgateway->router->router} laat zien hoe een heartbeat verstuurd wordt vanaf een gateway naar een router via een andere router.
Er is gekozen om de flow van een heartbeat bericht te laten zien omdat deze bij een forward ook een hop extra krijgt en daarmee het meest complex is.
Elke node heeft een eigen instantie van een routeringstechniek en draadloze communicatie, in deze diagram is gekozen om dezelfde te gebruiken om de leesbaarheid goed te houden.

Bij stap 3 is zichtbaar dat de routeringstechniek bij aanvraag voor een route naar node 2 een adres teruggegeven wordt van node 1 omdat via deze weg het bericht doorgegeven moet worden.
Vanaf stap 8 is zichtbaar wat er gebeurd als een bericht doorgestuurd moet worden.
Bij stap 9 wordt er eerst gekeken of er een route is naar de geadresseerde en aan wie het bericht dan doorgegeven moet worden.
Node 1 heeft een directe verbinding met node 2 dit wordt dan ook als adres doorgegeven in stap 10.
Vervolgens past de meshrouter het bericht aan dat zodat de zender en ontvanger weer juist staan. 
De waardes waar in staat wie de geadresseerde en maker van het bericht zijn blijven onaangepast.
Als het bericht van het type heartbeat is wordt deze apart genomen om er in stap 14 een hop bij op te tellen.
Als een heartbeat bericht meer hops heeft gemaakt dan dat er in de waarde van hop past wordt het bericht verwijderd en de flow gestopt.

In stap 16 wordt het bericht doorgestuurd naar de geadresseerde.
Als het bericht een heartbeat was wordt deze doorgestuurd anders wordt het aangepaste bericht verstuurt.

\subsubsection{Heartbeat van een router naar een andere router}
\label{DetailedDesign:Communicatie:sequence:heartbeatrouter->router}
\begin{figure}[H]
	\begin{center}\includegraphics[width=\linewidth]{UML/out/Communication/Sequence/RouterHeartbeatRouter/RouterHeartbeatRouter.png}\end{center}
	\caption{Sequence diagram van een router die een heartbeat stuurt naar een router.}
	\label{fig:communication:sequence:sequence:router->router}
\end{figure}
In de bovenstaande sequence diagram \ref{fig:communication:sequence:sequence:router->router} wordt de flow behandeld van een heartbeat van een router naar een andere router.
De keuze om dit in een sequence diagram uit te werken is om te laten zien dat er niet in elke scenario een reactie bericht verwacht hoeft te worden.

In stap 11 en 12 is bijvoorbeeld de afhandeling te zien als de zendende router verbinding heeft met een gateway en de ontvangende router niet.
In dit scenario gaat de router geen bericht terugsturen maar stelt hij de gateway die de zendende router heeft in als voorkeur en probeert een heartbeat te versturen naar deze gateway.    
Als het scenario omgedraaid is en de zendende router heeft geen verbinding met een gateway maar de ontvangende router wel stuurt hij juist wel een heartbeat terug. 
De zendende router zal hierdoor de zelfde stappen gaan uitvoeren als stap 11 en 12 waardoor hij weer een verbinding opbouwt met een gateway.

Dit houdt dus ook in als beide routers geen verbinding hebben met een gateway, of allebei wel, dat ze geen response sturen op een heartbeat.

\subsubsection{Informatieverspreiding bij verliezen contact met andere node}
\label{DetailedDesign:Communicatie:sequence:contactverlies}
Op het moment dat een node doorheeft dat er een verbinding verloren is met een andere node gaat hij de op hem aangesloten nodes daarover informeren. Dit zodat ieder andere node zijn routingstabel kan updaten 
\begin{figure}[H]
	\begin{center}\includegraphics[width=\linewidth]{UML/out/Communication/Sequence/LostConnectionWithOther/LostConnectionWithOther.png}\end{center}
	\caption{Sequence diagram van een component die zijn aangesloten nodes op de hoogte brengt van een verloren node.}
	\label{fig:communication:sequence:contactverlies}
\end{figure}

De eerste stap die een meshcomponent onderneemt is het raadplegen van de routeringstechniek of er direct aangesloten nodes zijn.
Per aangesloten node verstuurt het component een bericht dat er een node geen verbinding meer wil maken.
Een uitzondering is als de direct aangesloten node degene is die het component geïnformeerd heeft over het feit van de vermissing.
Die ontvangt geen bericht aangezien deze natuurlijk al op de hoogte is.


\subsection{Activity Diagrammen}
\label{DetailedDesign:Communicatie:Activity}

Aan de hand van de onderstaande activity diagrammen wordt de flow van de communicatie applicatie uitgelegd. 
In het component zijn twee soorten applicaties beschikbaar een router en een gateway. 
Deze worden eerst apart behandeld daarna zal de rest van het component aan bod komen.

Voor elk activity diagram telt dat er onder het diagram een begeleidende tekst is toegevoegd.

\subsubsection{Activity diagrammen router}
\label{DetailedDesign:Communicatie:Activity:router}

Eerst wordt de algemene flow van de router applicatie toegelicht vervolgens zullen protocollen worden toegelicht die optreden in bepaalde situaties.

\paragraph{Meshnetwerk router applicatie}
\label{DetailedDesign:Communicatie:Activity:router:applicatie}
De onderstaande flow zichtbaar in \autoref{fig:communication:activity:meshrouter} laat de algemene flow zien van de router applicatie. 


\begin{figure}[H]
	\begin{center}\includegraphics[width=.83\linewidth]{UML/out/Communication/activity/MeshRouter/MeshRouter.png}\end{center}
	\caption{Activity diagram meshnetwerk router applicatie.}
	\label{fig:communication:activity:meshrouter}
\end{figure}


Zodra het programma start wordt als eerste de antenne aan gezet en wanneer dit geactiveerd is ook de de debug stand van de antenne. 
Nadat deze is opgestart wordt kenbaar gemaakt aan de routeringstechniek dat deze ook kan starten met het opbouwen van routes.

Nu deze twee zijn opgestart kan de basis lus van het programma beginnen. 
Zolang het programma draait wordt deze lus herhaald.

Elke  keer zodra het programma op dit punt aankomt wacht het 10(instelbaar) seconden.
Hierna controleert de router of de aangesloten antenne nog aan staat. 
Als dit niet zo is begint de lus opnieuw.
Als de antenne wel aan staat wordt er een verzoek gedaan aan de routeringstechniek om onderhoudt te plegen.

Vervolgens zijn er twee paden mogelijke op basis van het feit of er verbinding is met een gateway.
Als er geen verbinding is wordt het protocol opgestart voor een verloren verbinding.
Hoe dit protocol werkt wordt apart toegelicht in het hierop volgende diagram.

Wanneer er wel verbinding is met een gateway wordt er gekeken  of de router ook op de hoogte is van de locatie van de router.
Als hij dit nog niet weet vraagt hij deze op bij de gateway.
Tenslotte wordt er een heartbeat verstuurt naar de gateway.

\pagebreak
\paragraph{Meshnetwerk router protocol bij verloren verbinding}
\label{DetailedDesign:Communicatie:Activity:verloren}
In het diagram getoond in \autoref{fig:communication:activity:verlorenverbinding} wordt het protocol uitgelegd die een router uitvoert zodra deze zijn verbinding heeft verloren met een gateway.

\begin{figure}[H]
	\begin{center}\includegraphics[width=1\linewidth]{UML/out/Communication/activity/LostConnection/LostConnection.png}\end{center}
	\caption{Activity diagram verloren verbinding protocol.}
	\label{fig:communication:activity:verlorenverbinding}
\end{figure}

Het protocol start op met het nogmaals checken of de gateway geen verbinding heeft.
Als er nog steeds geen verbinding is wordt er gekeken of er al een timer gestart is die bijhoudt hoelang er al geen verbinding meer is.

Als er nog geen timer gestart is wordt de routeringstechniek op de hoogte gebracht dat de verbinding verloren is met de gateway.
Vervolgens worden de direct aangesloten nodes ook op de hoogte gebracht van de verloren verbinding.
Tenslotte  wordt er een timer gestart door een boolean te schakelen en de huidige tijd op te slaan daarna wordt de functie verlaten.

Als er al wel een timer gestart is wordt er gekeken of de tijd die een node zonder verbinding mag zitten al verstreken is.
Als deze tijd nog niet verstreken is wordt de functie verlaten.

Wanneer de tijd wel verstreken is wordt het noodprotocol opgestart die in de volgende paragraaf beter wordt toegelicht.
Zodra dit protocol is uitgevoerd wordt de timer weer uitgezet zodat deze in een volgende lus weer opnieuw gaat lopen.
\pagebreak
\paragraph{Meshnetwerk router noodprotocol}
In \autoref{fig:communication:activity:nood} wordt het uitgevoerde protocol toegelicht die wordt uitgevoerd wanneer een node te lang zonder verbinding zit.

\begin{figure}[H]
	\begin{center}\includegraphics[width=\linewidth]{UML/out/Communication/activity/EmergencyProtocol/EmergencyProtocol.png}\end{center}
	\caption{Activity diagram noodprotocol.}
	\label{fig:communication:activity:nood}
\end{figure}

Het noodprotocol begint met een laatste check of de node ondertussen alweer verbinding heeft 
als dit zo is wordt het protocol niet uitgevoerd en de onderhandelingslijst leeg gehaald.

Wanneer er nog steeds geen verbinding is gelegd met een gateway wordt het protocol gestart.
Eerst wordt de routing techniek geraadpleegd of er nog andere nodes verbonden zijn met deze node.

Als dat niet zo is wordt er een verzoek gestuurd naar de drone om zich te gaan verplaatsen naar de locatie die als laatste gemarkeerde is als goede locatie.
Nadat deze verplaatst is wordt de locatie van de gateway ingesteld als laatst bekende goede locatie.
Ook wordt de routeringstechniek op de hoogte gesteld dat er een verplaatsing heeft plaats gevonden.
Als dit allemaal is uitgevoerd wordt dit protocol gesloten.

Wanneer er wel andere nodes verbonden zijn met deze node dan moeten deze onderling gaan onderhandelen wie er een verplaatsing moet gaan uitvoeren om zo efficiënt mogelijk het netwerk proberen te herstellen. Deze werking is apart uitgelegd in de hier opvolgende activity diagram \ref{fig:communication:activity:verplaatsingsonderhandeling}. Nadat deze onderhandelingen zijn afgelopen wordt het noodprotocol afgesloten zodat het netwerk even een moment heeft een poging te doen zichzelf te herstellen.
\pagebreak
\paragraph{Meshnetwerk router verplaatsingsonderhandeling}
\autoref{fig:communication:activity:verplaatsingsonderhandeling} laat de flow zien die een enkele node neemt wanneer deze start met onderhandelen over wie er een verplaatsing moet uitvoeren.


\begin{figure}[H]
	\begin{center}\includegraphics[width=.6\linewidth]{UML/out/Communication/activity/MovementNegotiation/MovementNegotiation.png}\end{center}
	\caption{Activity diagram verplaatsingsonderhandeling}
	\label{fig:communication:activity:verplaatsingsonderhandeling}
\end{figure}
De flow begint met het berekenen hoeveel punten de beweging van de node scoort.
In de opgeleverde applicatie worden de verplaatsingpunten op twee factoren gebaseerd.
Het aantal punten die een node krijgt staat gelijk aan de afstand die het heeft hemelsbreed met de gateway.
Een voorwaarde is wel dat de locatie waar de node zich naartoe wil gaan verplaatsen niet bezet wordt door een andere node. Als dit zo is worden de punten op -1 gezet waardoor die automatisch niet meer mee doet omdat er gekeken omdat het minimale aantal punten 0 is.

Hierna voegt de node zichzelf toe in de onderhandellijst en maakt hij zijn score bekend aan zijn aangesloten nodes.
Zodra de node dit bekend heeft gemaakt wacht hij tot de andere nodes dit ook hebben gedaan.

Als dit zover is kijkt de node of hij de hoogste score heeft in een lijst.

Wanneer een node de hoogste score heeft verzoekt hij de drone om zich te verplaatsen naar de laatst bekende goede locatie. Ook maakt de node dit bekend aan de routeringstechniek. 
Vervolgens stelt de node de locatie van de gateway in als laatste bekende goede locatie.

Tenslotte maakt de node altijd aan het einde van de onderhandeling de lijst waar alle onderhandel waardes in staan. 

\subsubsection{Activity diagrammen gateway}
\label{DetailedDesign:Communicatie:Activity:gateway}
In het volgende stuk worden de activity diagrammen behandeld die specifiek betrekking hebben op de gateway applicatie. Eerst wordt de algemene flow van de applicatie behandeld en daarna flows binnen de applicatie

\paragraph{Meshnetwerk gateway applicatie}
Deze paragraaf beschrijft de algemene flow van de gateway applicatie. 
\label{DetailedDesign:Communicatie:Activity:gateway:applicatie}
\begin{figure}[H]
	\begin{center}\includegraphics[width=.8\linewidth]{UML/out/Communication/activity/MeshGateway/MeshGateway.png}\end{center}
	\caption{Activity diagram meshnetwerk Gateway applicatie.}
	\label{fig:communication:activity:gateway}
\end{figure}

Zodra de gateway begint start hij meteen de antenne op van de draadloze communicatie.
Als debug aan staat verzoekt hij deze stand van de antenne om aan te gaan.
Na het starten van de antenne zoekt de gateway een verbinding op met het internet via de aangesloten \nameref{architectural:interfaces:IInternetConnection} om zo aansturen vanuit een extern punt van het meshnetwerk mogelijk te maken.

Daarna stelt hij de variabelen in die gebruikt worden in het netwerk om routers een weg naar de router toe te laten vinden. Voor nu worden de waarde dat er een verbinding is met de gateway altijd op waar gezet. In de toekomst kan dit nog veranderd worden op basis van het feit of er een internetverbinding is opgezet. 

Tenslotte begint de gateway met een verzoek naar de routeringstechniek om te starten met routeren. Waarna de gateway alleen nog periodiek een verzoek zal sturen om de routering te onderhouden.

\subsubsection{Meshnetwerk algemene applicatie}
Dit volgende stuk beschrijft de flows in de applicatie die zowel de router als de gateway volgen. 

\paragraph{Meshnetwerk flow bij ontvangst bericht}
\label{DetailedDesign:Communicatie:Activity:meshcomponent:onmsg}
Deze paragraaf beschrijft acties die de applicatie onderneemt bij het ontvangen van een bericht. 
\begin{figure}[H]
	\begin{center}\includegraphics[width=.8\linewidth]{UML/out/Communication/activity/processMessage/processMessage.png}\end{center}
	\caption{Activity diagram meshnetwerk flow ontvangen bericht}
	\label{fig:communication:meshcomponent:onmsg}
\end{figure}

In het acitvity diagram is te zien dat er bij het ontvangen van een bericht eerst wordt gekeken of het bericht geadresseerd is voor de ontvangende node.
Als die niet zo is dan wordt het bericht doorgestuurd naar een volgend punt.

Wanneer het wel geadresseerd is voor de ontvangende node dan gaat het de functie in om het bericht te verwerken. Hoe het bericht verwerkt wordt is afhankelijk van het type die het bericht bij zich draagt. Dit wordt gedaan aan de hand van een switch case.

\paragraph{Routeringstechniek voor het vinden van een pad tot het adres}
\label{DetailedDesign:Communicatie:Activity:routeringtechniek:aanvraag}
In het communicatie component is een routeringstechniek aanwezig voor het vinden van een route tot een pad. Hoe deze techniek het volgende adres vindt in de route wordt getoond in het volgende activity diagram. 

\begin{figure}[H]
	\begin{center}\includegraphics[width=.45\linewidth]{UML/out/Communication/activity/padtotadres/padtotadres.png}\end{center}
	\caption{Activity diagram vinden pad tot adres}
	\label{fig:communication:routeringtechniek:aanvraag}
\end{figure}

In het diagram is te zien dat er drie uitgang situaties zijn. 
Eerst zal de techniek kijken of het adres behoord tot een direct aangesloten node en als dat zo is geeft hij dit terug.
Als er direct aangesloten node is gevonden kijkt het systeem of een van de aangesloten nodes het adres kent.
Wanneer een aangesloten node het adres kent geeft de routeringstechniek het adres van de aangesloten node terug.
Tenslotte als niemand het adres kent wordt dit terug gegeven.

\paragraph{Routeringstechniek actie bij bewijs van contact}
\label{DetailedDesign:Communicatie:Activity:routeringtechniek:contactgevonden}
Als een node bewijs heeft dat er een verbinding is geeft hij dit door aan de routeringstechniek die verwerkt dat in de huidige implementatie op de volgende manier.

\begin{figure}[H]
	\begin{center}\includegraphics[width=.45\linewidth]{UML/out/Communication/activity/contactgevonden/contactgevonden.png}\end{center}
	\caption{Activity diagram vinden pad tot adres}
	\label{fig:communication:routeringtechniek:gevonde}
\end{figure}

Op het moment dat er contact gelegd is dan wordt er gekeken of dit direct contact was of dat er een aangesloten node een nieuw contact heeft gevonden. Als het direct contact was komt er een nieuwe route aftakking door het toevoegen van een kind van de node.
Als er indirect een nieuw contact wordt gevonden dan wordt de gene die dit aangeeft geregistreerd als nieuw punt wanneer die nog onbekend was. Vervolgens wordt aan het adres die gevonden is toegevoegd aan de set van de gene die de vondst aangeeft.

\subsection{Design decisions made for the sub-system}

\section{Design Sub-Systeem gazebo}
\label{DetailedDesign:MeshNetwerk}
Het sub syteem gazebo is het component die verantwoordelijk is voor de simulatie van de drones. 
Het is zowel verantwoordelijk voor het initialiseren van de virtuele hardware als aan elkaar koppelen van deze hardware.
Hoewel het nu nog niet van toepassing is zal gazebo uiteindelijk ook verantwoordelijk voor het toepassen van physics op de virutele drones. 


\subsection{Component Diagram}
\label{DetailedDesign:MeshNetwerk:ComponentDiagram}
\begin{figure}[H]
	\begin{center}\includegraphics[width=\linewidth]{Afbeeldingen/gazeboComponentDiagram.png}\end{center}
	\caption{component diagram gazebo}
	\label{fig:component:gazebo}
\end{figure}

%NAMESPACE GAZEBO
\subsubsection{ArduinoSimulation}
\label{architectural:subcomponenten:ArduinoSimulation}
In de dit component wordt een arduino gesimuleerd, deze simulatie is puur functioneel en betreft alleen een gelijk gedrag met betrekking tot de Arduino sketch. 
Het heeft geen effect op de clock snelheid deze is gelijk aan de computer waarop de software draait. 

\subsubsection{VirtualArduino}
\label{architectural:subcomponenten:VirtualArduino}
Dit abstracte component verplicht elke virtuele Arduino tot het aanmaken van een setup en loop functie zoals dit ook is in Arduino sketches.
Omdat deze Arduino altijd wordt toegevoegd aan een ander model erft dit component over van modelplugin.    

\subsubsection{VirtualArduinoRouter}
\label{architectural:subcomponenten:VirtualArduinoRouter}
Deze \nameref{architectural:subcomponenten:VirtualArduino} is voorzien van een sketch die de arduino zich laat gedragen als in router in het meshnetwerk. 

\subsubsection{VirtualArduinoGateway}
\label{architectural:subcomponenten:VirtualArduinoGateway}
Deze \nameref{architectural:subcomponenten:VirtualArduino} is voorzien van een sketch die de arduino zich laat gedragen als in gateway in het meshnetwerk. 


\subsubsection{DroneSimulation}
\label{architectural:subcomponenten:DroneSimulation}
Dit component is verantwoordelijk voor het simuleren van drones. 

\subsubsection{DroneEngine}
\label{architectural:subcomponenten:DroneEngine}
Elke \nameref{architectural:subcomponenten:VirtualDrone} is voorzien deze drone engine. 
Dit component maakt het mogelijk voor een drone om zich in een rechte lijn door lucht zich te verplaatsen waarbij het opstijgen en de landing verticaal wordt uitgevoerd.
Daarnaast biedt dit component via een rosservice het deel van de interface \nameref{architectural:interfaces:IDroneEngine} aan om de huidige locatie op te vragen.
Via een rostopic kan er een doel gestuurd gestuurd worden om het andere deel van de net genoemde interface te voorzien.
Tenslotte stuurt dit component bij elke verplaatsing de huidige locatie door naar de \nameref{architectural:subcomponenten:WirelessSignalSimulator}. 

\subsubsection{VirtualDrone}
\label{architectural:subcomponenten:VirtualDrone}
Een virtuele drone is een abstract component die alle variabelen bevat die nodig zijn om een drone in de wereld te injecteren. Deze variabelen betreffen een drone id, locatie en verwijzing naar de gazebo wereld. 

\subsubsection{GatewayDrone}
\label{architectural:subcomponenten:GatewayDrone}
Deze drone is een \nameref{architectural:subcomponenten:VirtualDrone} die in de sdf omschrijving wordt voorzien van een \nameref{architectural:subcomponenten:VirtualArduinoGateway} plugin. 
\subsubsection{RouterDrone}
\label{architectural:subcomponenten:RouterDrone}
Deze drone is een \nameref{architectural:subcomponenten:VirtualDrone} die in de sdf omschrijving wordt voorzien van een \nameref{architectural:subcomponenten:VirtualArduinoRouter} plugin. 

\subsubsection{DroneFactory}
\label{architectural:subcomponenten:DroneFactory}
Dit component is verantwoordelijk voor het produceren van drones. Het is een WorldPlugin die aan de hand van meegegeven parameters gateway en router drones aanmaakt. 

\subsection{Interfaces}
\label{DetailedDesign:MeshNetwerk:interfaces}
In de vorm van ros transport types voldoet het gazebo component aan extern aangeboden interfaces.
Door gebruik te maken van een ServiceServer \nameref{architectural:ros:service:RequestGPS} en een subscriber op het topic \nameref{architectural:ros:topic:Location} die samen de functionaliteit bieden benodigd voor de interface \nameref{architectural:interfaces:IDroneEngine}. 
Door informatie te publiceren op het topic \nameref{architectural:ros:topic:DroneInfo} biedt het informatie per drone aan over locaties.

\subsubsection{RequestGPS}
\label{DetailedDesign:MeshNetwerk:interfaces:requestgps}

Elke drone engine maakt een service aan met de naam "\slash Drones/drone\textunderscore id/gps"	waarbij de drone\textunderscore id een variabele is.
De structuur van de service ziet er als volgt uit.
\begin{lstlisting}
---
float32 latitude
float32 longitude
int16 height
\end{lstlisting}

Deze service heeft geen parameters waaraan voldaan moet worden. 
Als response geeft het de huidige locatie terug van de drone.

\subsubsection{Location}
\label{DetailedDesign:MeshNetwerk:interfaces:location}

Door het luisteren naar het topic "\slash Drones/drone\textunderscore id/goal"\  is het mogelijk om doelen te sturen naar de drone. 
Dit gebeurd door Location berichten te sturen naar de drone welke de volgende structuur hebben.

\begin{lstlisting}
float32 latitude
float32 longitude
int16 height
\end{lstlisting}

Bij ontvangst stelt de DroneEngine de ontvangen locatie in als doel.

\subsubsection{DroneInfo}
\label{DetailedDesign:MeshNetwerk:interfaces:droneinfo}
Tenslotte publiceert de drone informatie op het topic "\slash WirelessSignalSimulator\slash.
Hiervoor gebruikt het het bericht DroneInfo die de volgende structuur heeft:

\begin{lstlisting}
uint8 nodeID
float32[3] position
string sub
bool on
\end{lstlisting}



\subsection{Sequence Diagrams}
\label{DetailedDesign:MeshNetwerk:sequence}
\subsection{Activity and State Diagrams}
\label{DetailedDesign:MeshNetwerk:activity}
\subsection{Design decisions made for the sub-system}
\label{DetailedDesign:MeshNetwerk:decisions}

\section{Design Sub-System ros}
\label{DetailedDesign:WirelessSimulatie}
\subsection{Component Diagram}
\label{DetailedDesign:ros:ComponentDiagram}
\begin{figure}[H]
	\begin{center}\includegraphics[width=\linewidth]{Afbeeldingen/rosComponentDiagram.png}\end{center}
	\caption{component diagram ros}
	\label{fig:component:ros}
\end{figure}

%NAMESPACE Ros
\subsubsection{RosDroneEngineConnector}
\label{architectural:subcomponenten:RosDroneEngineConnector}
Dit component is een adapter tussen de \nameref{architectural:subcomponenten:DroneEngine} en de interface \nameref{architectural:interfaces:IDroneEngine}. Die het mogelijk maakt om ros te gebruiken om aanspraak te maken op de virtuele drone.

\subsubsection{DroneManagerService}
\label{architectural:subcomponenten:DroneManagerService}
Dit component is de toegangspoort voor de ontwikkelaar tot de \nameref{architectural:subcomponenten:MeshnetworkGateway}.
Op dit moment is het component alleen geschikt om verplaatsingverzoeken te versturen via de gateway naar de Drones.
Hiervoor biedt het twee interfaces in de vorm van rosservices aan waarbij er een voor locaties is en de ander voor casussen. 

\subsubsection{DroneManager}
\label{architectural:subcomponenten:DroneManager}
Dit subcomponent realiseert de rosservices en publiceert verplaatsingverzoeken naar de gateways.  

\subsubsection{RosInternetMock}
\label{architectural:subcomponenten:RosInternetMock}
Deze internetmock laat de \nameref{architectural:subcomponenten:DroneManager} zich voordoen als internetpunt zodat er geen daadwerkelijke TCP/IP implementatie hoeft worden gemaakt 
\subsubsection{WirelessSimulation}
\label{architectural:subcomponenten:WirelessSimulation}
Het WirelessSimulation component is verantwoordelijk voor het simuleren van de NRF24 en het draadloze signaal hiervan. 
\subsubsection{WirelessSignalSimulator}
\label{architectural:subcomponenten:WirelessSignalSimulator}
Deze simulator bepaald of twee nodes met elkaar mogen communiceren. Het doet dit op basis van informatie die het continue ontvangt via het drone informatie topic. 
\subsubsection{Node}
\label{architectural:subcomponenten:Node}
Dit component wordt alleen gebruikt door de \nameref{architectural:subcomponenten:WirelessSignalSimulator} om te registreren welke Nodes bestaan, waar ze zijn en naar welk topic ze luisteren.
\subsubsection{VirtualNRF24}
\label{architectural:subcomponenten:VirtualNRF24}
Dit component is de virtuele versie van de NRF24, het is in staat om payloads te verwerken van 32 byte.
Deze kan de NRF24 naar een direct adres versturen of zenden naar alle NRF24 nodes binnen bereik.


\subsection{Sequence Diagrams}
\label{DetailedDesign:WirelessSimulatie:sequence}
\subsection{Activity and State Diagrams}
\label{DetailedDesign:WirelessSimulatie:activity}
\subsection{Design decisions made for the sub-system}
\label{DetailedDesign:WirelessSimulatie:decisions}

\section{Design Sub-System NRF24}
\label{DetailedDesign:NRF24}
\subsection{Component Diagram}
\label{DetailedDesign:NRF24:ComponentDiagram}
\begin{figure}[H]
	\begin{center}\includegraphics[width=.5\linewidth]{Afbeeldingen/NRF24ComponentDiagram.png}\end{center}
	\caption{component diagram ros}
	\label{fig:component:NRF24}
\end{figure}
\subsection{Sequence Diagrams}
\label{DetailedDesign:NRF24:sequence}
\subsection{Activity and State Diagrams}
\label{DetailedDesign:NRF24:activity}
\subsection{Design decisions made for the sub-system}
\label{DetailedDesign:NRF24:decisions}


\bibliographystyle{apacite}
\bibliography{bilbliography.bib}

\clearpage
\appendix
\chapter{Appendix 1}
\label{app:iteratieplan}





\end{document}