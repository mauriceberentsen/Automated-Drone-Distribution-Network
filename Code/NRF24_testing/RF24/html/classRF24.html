<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Optimized High Speed NRF24L01+ Driver Class Documenation: RF24 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Optimized High Speed NRF24L01+ Driver Class Documenation
   &#160;<span id="projectnumber">V1.0</span>
   </div>
   <div id="projectbrief">TMRh20 2014 - Optimized Fork of NRF24L01+ Driver</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRF24-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RF24 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="RF24_8h_source.html">RF24.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Primary public interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are the main methods you need to operate the chip </p>
</div></td></tr>
<tr class="memitem:af564e19261afb56005d2411d0c7b05de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#af564e19261afb56005d2411d0c7b05de">RF24</a> (uint16_t _cepin, uint16_t _cspin)</td></tr>
<tr class="separator:af564e19261afb56005d2411d0c7b05de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085d99c986effa19b01c030e2b1439ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a085d99c986effa19b01c030e2b1439ce">RF24</a> (uint16_t _cepin, uint16_t _cspin, uint32_t spispeed)</td></tr>
<tr class="separator:a085d99c986effa19b01c030e2b1439ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56311ab4c4042525c166e81e0a09890c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a56311ab4c4042525c166e81e0a09890c">~RF24</a> ()</td></tr>
<tr class="separator:a56311ab4c4042525c166e81e0a09890c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048a20c73c7d9b2e02dcbae6fb9c4ba8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a048a20c73c7d9b2e02dcbae6fb9c4ba8">begin</a> (void)</td></tr>
<tr class="separator:a048a20c73c7d9b2e02dcbae6fb9c4ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac224c55270d26dbe7b4f3492ea3056b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ac224c55270d26dbe7b4f3492ea3056b5">isChipConnected</a> ()</td></tr>
<tr class="separator:ac224c55270d26dbe7b4f3492ea3056b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a2733a3889bdc331fe2d2f4f0f7b39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening</a> (void)</td></tr>
<tr class="separator:a30a2733a3889bdc331fe2d2f4f0f7b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f144d73fc447c8ac2d1a4166210fd88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening</a> (void)</td></tr>
<tr class="separator:a6f144d73fc447c8ac2d1a4166210fd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127105eb7a3b351cfe777c1cec50627a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a127105eb7a3b351cfe777c1cec50627a">available</a> (void)</td></tr>
<tr class="separator:a127105eb7a3b351cfe777c1cec50627a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2eacacfba96426c192066f04054c5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a8e2eacacfba96426c192066f04054c5b">read</a> (void *buf, uint8_t len)</td></tr>
<tr class="separator:a8e2eacacfba96426c192066f04054c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd4c198a47704db20b6b5cf0731cd58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write</a> (const void *buf, uint8_t len)</td></tr>
<tr class="separator:a4cd4c198a47704db20b6b5cf0731cd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e409e62d49a23e372a70b904ae30e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe</a> (const uint8_t *address)</td></tr>
<tr class="separator:af2e409e62d49a23e372a70b904ae30e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edc910ccc1ffcff56814b08faca5535"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a> (uint8_t number, const uint8_t *address)</td></tr>
<tr class="separator:a9edc910ccc1ffcff56814b08faca5535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Deprecated</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods provided for backwards compabibility. </p>
</div></td></tr>
<tr class="memitem:aa7e8523f86f9f8f20c274e0c89a5fd45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aa7e8523f86f9f8f20c274e0c89a5fd45">openReadingPipe</a> (uint8_t number, uint64_t address)</td></tr>
<tr class="separator:aa7e8523f86f9f8f20c274e0c89a5fd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c8e68ee840e1860a31dbdc83afbd77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a50c8e68ee840e1860a31dbdc83afbd77">openWritingPipe</a> (uint64_t address)</td></tr>
<tr class="separator:a50c8e68ee840e1860a31dbdc83afbd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575c061519e7820e1850ad380c617d95"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a575c061519e7820e1850ad380c617d95">flush_rx</a> (void)</td></tr>
<tr class="separator:a575c061519e7820e1850ad380c617d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5a669f1c68203d5317f8f452a2bff1b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a5a669f1c68203d5317f8f452a2bff1b5">beginTransaction</a> ()</td></tr>
<tr class="separator:a5a669f1c68203d5317f8f452a2bff1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b196efad61a1b8a9bf493150901edb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a2b196efad61a1b8a9bf493150901edb4">endTransaction</a> ()</td></tr>
<tr class="separator:a2b196efad61a1b8a9bf493150901edb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Advanced Operation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpaf32cf1216e734b82e2b52429dae0bf6"></a> Methods you can use to drive the chip in more advanced ways </p>
</td></tr>
<tr class="memitem:a2e40fe66d1231a333aa2534e8491f828"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a2e40fe66d1231a333aa2534e8491f828">failureDetected</a></td></tr>
<tr class="separator:a2e40fe66d1231a333aa2534e8491f828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc95213ed4c8569a90eb33122e16cea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#adc95213ed4c8569a90eb33122e16cea6">printDetails</a> (void)</td></tr>
<tr class="separator:adc95213ed4c8569a90eb33122e16cea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7dd139fabc16b77cb8325faa07620f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ace7dd139fabc16b77cb8325faa07620f">available</a> (uint8_t *pipe_num)</td></tr>
<tr class="separator:ace7dd139fabc16b77cb8325faa07620f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22e44fe1a68747872fcb304a407fd30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ad22e44fe1a68747872fcb304a407fd30">rxFifoFull</a> ()</td></tr>
<tr class="separator:ad22e44fe1a68747872fcb304a407fd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a51923a09ba4f3478aba9be0f8a6a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aa0a51923a09ba4f3478aba9be0f8a6a1">powerDown</a> (void)</td></tr>
<tr class="separator:aa0a51923a09ba4f3478aba9be0f8a6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdaf47aa0edd6dca1b9a8bb7972a1a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a5cdaf47aa0edd6dca1b9a8bb7972a1a3">powerUp</a> (void)</td></tr>
<tr class="separator:a5cdaf47aa0edd6dca1b9a8bb7972a1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bfe6502d74bb5bbccb3a7f2ba2b5ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a23bfe6502d74bb5bbccb3a7f2ba2b5ea">write</a> (const void *buf, uint8_t len, const bool multicast)</td></tr>
<tr class="separator:a23bfe6502d74bb5bbccb3a7f2ba2b5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b2516993481b58e724d1274a7fd9cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a> (const void *buf, uint8_t len)</td></tr>
<tr class="separator:a47b2516993481b58e724d1274a7fd9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16d53de0327c0b41d170cbda4bf41af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ad16d53de0327c0b41d170cbda4bf41af">writeFast</a> (const void *buf, uint8_t len, const bool multicast)</td></tr>
<tr class="separator:ad16d53de0327c0b41d170cbda4bf41af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fd8d5ee490d54ae1cb2e8fefee535f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ae6fd8d5ee490d54ae1cb2e8fefee535f">writeBlocking</a> (const void *buf, uint8_t len, uint32_t timeout)</td></tr>
<tr class="separator:ae6fd8d5ee490d54ae1cb2e8fefee535f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cc453453c94969d4d3f0edb3778c83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a> ()</td></tr>
<tr class="separator:a12cc453453c94969d4d3f0edb3778c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f54decbe9d06cb026a5d3dfb505116"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ab7f54decbe9d06cb026a5d3dfb505116">txStandBy</a> (uint32_t timeout, bool startTx=0)</td></tr>
<tr class="separator:ab7f54decbe9d06cb026a5d3dfb505116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65619238c25036c3de72dc2c1a1c6e52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a65619238c25036c3de72dc2c1a1c6e52">writeAckPayload</a> (uint8_t pipe, const void *buf, uint8_t len)</td></tr>
<tr class="separator:a65619238c25036c3de72dc2c1a1c6e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c2736fd0df9c8128cef408c8b88e92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a30c2736fd0df9c8128cef408c8b88e92">isAckPayloadAvailable</a> (void)</td></tr>
<tr class="separator:a30c2736fd0df9c8128cef408c8b88e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb97dc4bdf4d2d84ea44060ac5b4ed89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened</a> (bool &amp;tx_ok, bool &amp;tx_fail, bool &amp;rx_ready)</td></tr>
<tr class="separator:afb97dc4bdf4d2d84ea44060ac5b4ed89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd19843064cb70ec23507412e519e4ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#acd19843064cb70ec23507412e519e4ef">startFastWrite</a> (const void *buf, uint8_t len, const bool multicast, bool startTx=1)</td></tr>
<tr class="separator:acd19843064cb70ec23507412e519e4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27519fc289920094422033e0bbf8cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aa27519fc289920094422033e0bbf8cf9">startWrite</a> (const void *buf, uint8_t len, const bool multicast)</td></tr>
<tr class="separator:aa27519fc289920094422033e0bbf8cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf7fa54d3ab2a85ce215b4bf6ae933b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aeaf7fa54d3ab2a85ce215b4bf6ae933b">reUseTX</a> ()</td></tr>
<tr class="separator:aeaf7fa54d3ab2a85ce215b4bf6ae933b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7915b1d2661a82137573344f659e81"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#adb7915b1d2661a82137573344f659e81">flush_tx</a> (void)</td></tr>
<tr class="separator:adb7915b1d2661a82137573344f659e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d522ccf39493510e64bf1740be790d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ad0d522ccf39493510e64bf1740be790d">testCarrier</a> (void)</td></tr>
<tr class="separator:ad0d522ccf39493510e64bf1740be790d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821285f3b54553f4402eb3fd0ac6d6c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a821285f3b54553f4402eb3fd0ac6d6c1">testRPD</a> (void)</td></tr>
<tr class="separator:a821285f3b54553f4402eb3fd0ac6d6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e5f1533b7753806c42b76e782d917e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a35e5f1533b7753806c42b76e782d917e">isValid</a> ()</td></tr>
<tr class="separator:a35e5f1533b7753806c42b76e782d917e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9944d93994a80037e3586f340f5e0107"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a9944d93994a80037e3586f340f5e0107">closeReadingPipe</a> (uint8_t pipe)</td></tr>
<tr class="separator:a9944d93994a80037e3586f340f5e0107"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Optional Configurators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpe1a83b99ec8153e5baf680edeeed1586"></a> Methods you can use to get or set the configuration of the chip. None are required. Calling <a class="el" href="classRF24.html#a048a20c73c7d9b2e02dcbae6fb9c4ba8">begin()</a> sets up a reasonable set of defaults. </p>
</td></tr>
<tr class="memitem:a958fb99f54415101ca008ab11b3bfe79"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a958fb99f54415101ca008ab11b3bfe79">txDelay</a></td></tr>
<tr class="separator:a958fb99f54415101ca008ab11b3bfe79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08121bf844f08dbe53f51576b7c4066"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ad08121bf844f08dbe53f51576b7c4066">csDelay</a></td></tr>
<tr class="separator:ad08121bf844f08dbe53f51576b7c4066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aea7f9a3bd9c7d357fb296ce751f21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ad5aea7f9a3bd9c7d357fb296ce751f21">setAddressWidth</a> (uint8_t a_width)</td></tr>
<tr class="separator:ad5aea7f9a3bd9c7d357fb296ce751f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6d3959c8320e64568395f4ef507aef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a4c6d3959c8320e64568395f4ef507aef">setRetries</a> (uint8_t <a class="el" href="group__Porting__General.html#ga70a331e8ddf9acf9d33c47b71cda4c5f">delay</a>, uint8_t count)</td></tr>
<tr class="separator:a4c6d3959c8320e64568395f4ef507aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6e5a5f6c85d2638381cab2c0f3702e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a5e6e5a5f6c85d2638381cab2c0f3702e">setChannel</a> (uint8_t channel)</td></tr>
<tr class="separator:a5e6e5a5f6c85d2638381cab2c0f3702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a66a94609309e17edaa1919e66cea0a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a6a66a94609309e17edaa1919e66cea0a">getChannel</a> (void)</td></tr>
<tr class="separator:a6a66a94609309e17edaa1919e66cea0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343e5d23477181011dea030fafb1954f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a343e5d23477181011dea030fafb1954f">setPayloadSize</a> (uint8_t size)</td></tr>
<tr class="separator:a343e5d23477181011dea030fafb1954f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa0c7cbe3d38fef4722f3f1d2d6c5f1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1">getPayloadSize</a> (void)</td></tr>
<tr class="separator:a0aa0c7cbe3d38fef4722f3f1d2d6c5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65963ed8d8fd45f847e2f673995b85e1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a65963ed8d8fd45f847e2f673995b85e1">getDynamicPayloadSize</a> (void)</td></tr>
<tr class="separator:a65963ed8d8fd45f847e2f673995b85e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8efced2ee9edbcc6510878b20edc1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload</a> (void)</td></tr>
<tr class="separator:abf8efced2ee9edbcc6510878b20edc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443888504975d7441d6452a09d09a8fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a443888504975d7441d6452a09d09a8fa">enableDynamicPayloads</a> (void)</td></tr>
<tr class="separator:a443888504975d7441d6452a09d09a8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486c4c47a6973614ae595ae96f221165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a486c4c47a6973614ae595ae96f221165">disableDynamicPayloads</a> (void)</td></tr>
<tr class="separator:a486c4c47a6973614ae595ae96f221165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6253607ac2a1995af91a35cea6899c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck</a> ()</td></tr>
<tr class="separator:a6253607ac2a1995af91a35cea6899c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62846750b82682beb7593719eb60ed60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a62846750b82682beb7593719eb60ed60">isPVariant</a> (void)</td></tr>
<tr class="separator:a62846750b82682beb7593719eb60ed60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec71746d59da978bcbb975167886a2cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck</a> (bool enable)</td></tr>
<tr class="separator:aec71746d59da978bcbb975167886a2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dba9e558f3620ab489af68ea3dea9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a60dba9e558f3620ab489af68ea3dea9c">setAutoAck</a> (uint8_t pipe, bool enable)</td></tr>
<tr class="separator:a60dba9e558f3620ab489af68ea3dea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedac579590a668ae97baccab284de8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#adedac579590a668ae97baccab284de8a">setPALevel</a> (uint8_t level)</td></tr>
<tr class="separator:adedac579590a668ae97baccab284de8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c4dcd84466168c5816382ceb366067"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#af7c4dcd84466168c5816382ceb366067">getPALevel</a> (void)</td></tr>
<tr class="separator:af7c4dcd84466168c5816382ceb366067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9920e7a95699748b003c4a839b0814"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aeb9920e7a95699748b003c4a839b0814">setDataRate</a> (<a class="el" href="RF24_8h.html#a82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a> speed)</td></tr>
<tr class="separator:aeb9920e7a95699748b003c4a839b0814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a7b11dafe8ffab6135f243decce0d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="RF24_8h.html#a82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a72a7b11dafe8ffab6135f243decce0d7">getDataRate</a> (void)</td></tr>
<tr class="separator:a72a7b11dafe8ffab6135f243decce0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f626fc4a58dd997153bcc0f8198b9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a89f626fc4a58dd997153bcc0f8198b9e">setCRCLength</a> (<a class="el" href="RF24_8h.html#adbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a> length)</td></tr>
<tr class="separator:a89f626fc4a58dd997153bcc0f8198b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4ca91b829afcd94a4c11e0343e3796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="RF24_8h.html#adbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aba4ca91b829afcd94a4c11e0343e3796">getCRCLength</a> (void)</td></tr>
<tr class="separator:aba4ca91b829afcd94a4c11e0343e3796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eacd9ecfbc19864801d714c292cf8be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a5eacd9ecfbc19864801d714c292cf8be">disableCRC</a> (void)</td></tr>
<tr class="separator:a5eacd9ecfbc19864801d714c292cf8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf68b9b0c9cd17179e9e144c3e7f9c45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#abf68b9b0c9cd17179e9e144c3e7f9c45">maskIRQ</a> (bool tx_ok, bool tx_fail, bool rx_ready)</td></tr>
<tr class="separator:abf68b9b0c9cd17179e9e144c3e7f9c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Driver for nRF24L01(+) 2.4GHz Wireless Transceiver </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="gettingstarted_8cpp-example.html#_a0">gettingstarted.cpp</a>, <a class="el" href="GettingStarted_8ino-example.html#_a0">GettingStarted.ino</a>, <a class="el" href="gettingstarted_call_response_8cpp-example.html#_a0">gettingstarted_call_response.cpp</a>, <a class="el" href="GettingStarted_CallResponse_8ino-example.html#_a0">GettingStarted_CallResponse.ino</a>, <a class="el" href="GettingStarted_HandlingData_8ino-example.html#_a0">GettingStarted_HandlingData.ino</a>, <a class="el" href="GettingStarted_HandlingFailures_8ino-example.html#_a0">GettingStarted_HandlingFailures.ino</a>, <a class="el" href="pingpair_ack_8ino-example.html#_a0">pingpair_ack.ino</a>, <a class="el" href="pingpair_dyn_8cpp-example.html#_a0">pingpair_dyn.cpp</a>, <a class="el" href="pingpair_dyn_8ino-example.html#_a0">pingpair_dyn.ino</a>, <a class="el" href="pingpair_irq_8ino-example.html#_a0">pingpair_irq.ino</a>, <a class="el" href="pingpair_irq_simple_8ino-example.html#_a0">pingpair_irq_simple.ino</a>, <a class="el" href="pingpair_sleepy_8ino-example.html#_a0">pingpair_sleepy.ino</a>, <a class="el" href="rf24ping85_8ino-example.html#_a0">rf24ping85.ino</a>, <a class="el" href="scanner_8ino-example.html#_a0">scanner.ino</a>, <a class="el" href="starping_8pde-example.html#_a0">starping.pde</a>, <a class="el" href="transfer_8cpp-example.html#_a0">transfer.cpp</a>, <a class="el" href="Transfer_8ino-example.html#_a0">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#_a0">TransferTimeouts.ino</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="RF24_8h_source.html#l00051">51</a> of file <a class="el" href="RF24_8h_source.html">RF24.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af564e19261afb56005d2411d0c7b05de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af564e19261afb56005d2411d0c7b05de">&#9670;&nbsp;</a></span>RF24() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF24::RF24 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_cepin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_cspin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Arduino Constructor</p>
<p>Creates a new instance of this driver. Before using, you create an instance and send in the unique pins that this chip is connected to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cepin</td><td>The pin attached to Chip Enable on the RF module </td></tr>
    <tr><td class="paramname">_cspin</td><td>The pin attached to Chip Select </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00435">435</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a085d99c986effa19b01c030e2b1439ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085d99c986effa19b01c030e2b1439ce">&#9670;&nbsp;</a></span>RF24() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF24::RF24 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_cepin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_cspin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>spispeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optional Linux Constructor</p>
<p>Creates a new instance of this driver. Before using, you create an instance and send in the unique pins that this chip is connected to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cepin</td><td>The pin attached to Chip Enable on the RF module </td></tr>
    <tr><td class="paramname">_cspin</td><td>The pin attached to Chip Select </td></tr>
    <tr><td class="paramname">spispeed</td><td>For RPi, the SPI speed in MHZ ie: BCM2835_SPI_SPEED_8MHZ </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00446">446</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a56311ab4c4042525c166e81e0a09890c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56311ab4c4042525c166e81e0a09890c">&#9670;&nbsp;</a></span>~RF24()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual RF24::~RF24 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RF24_8h_source.html#l00128">128</a> of file <a class="el" href="RF24_8h_source.html">RF24.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5a669f1c68203d5317f8f452a2bff1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a669f1c68203d5317f8f452a2bff1b5">&#9670;&nbsp;</a></span>beginTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::beginTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>SPI transactions</p>
<p>Common code for SPI transactions including CSN toggle </p>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00085">85</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a2b196efad61a1b8a9bf493150901edb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b196efad61a1b8a9bf493150901edb4">&#9670;&nbsp;</a></span>endTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::endTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00094">94</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a048a20c73c7d9b2e02dcbae6fb9c4ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048a20c73c7d9b2e02dcbae6fb9c4ba8">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begin operation of the chip</p>
<p>Call this in setup(), before calling any other methods. </p><div class="fragment"><div class="line">radio.begin() </div></div><!-- fragment --> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_HandlingData_8ino-example.html#a1">GettingStarted_HandlingData.ino</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00589">589</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="ac224c55270d26dbe7b4f3492ea3056b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac224c55270d26dbe7b4f3492ea3056b5">&#9670;&nbsp;</a></span>isChipConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::isChipConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the chip is connected to the SPI bus </p>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00715">715</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a30a2733a3889bdc331fe2d2f4f0f7b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a2733a3889bdc331fe2d2f4f0f7b39">&#9670;&nbsp;</a></span>startListening()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::startListening </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start listening on the pipes opened for reading.</p>
<ol type="1">
<li>Be sure to call <a class="el" href="classRF24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe()</a> first.</li>
<li>Do not call <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> while in this mode, without first calling <a class="el" href="classRF24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening()</a>.</li>
<li>Call <a class="el" href="classRF24.html#a127105eb7a3b351cfe777c1cec50627a">available()</a> to check for incoming traffic, and <a class="el" href="classRF24.html#a8e2eacacfba96426c192066f04054c5b">read()</a> to get it.</li>
</ol>
<div class="fragment"><div class="line">Open reading pipe 1 <span class="keyword">using</span> address CCCECCCECC</div><div class="line"> </div><div class="line">byte address[] = { 0xCC,0xCE,0xCC,0xCE,0xCC };</div><div class="line">radio.openReadingPipe(1,address);</div><div class="line">radio.startListening();</div></div><!-- fragment --> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_HandlingData_8ino-example.html#a6">GettingStarted_HandlingData.ino</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00728">728</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a6f144d73fc447c8ac2d1a4166210fd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f144d73fc447c8ac2d1a4166210fd88">&#9670;&nbsp;</a></span>stopListening()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::stopListening </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop listening for incoming messages, and switch to transmit mode.</p>
<p>Do this before calling <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>. </p><div class="fragment"><div class="line">radio.stopListening();</div><div class="line">radio.write(&amp;data,<span class="keyword">sizeof</span>(data));</div></div><!-- fragment --> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_HandlingData_8ino-example.html#a7">GettingStarted_HandlingData.ino</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00759">759</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a127105eb7a3b351cfe777c1cec50627a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127105eb7a3b351cfe777c1cec50627a">&#9670;&nbsp;</a></span>available() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether there are bytes available to be read </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(radio.available()){</div><div class="line">  radio.read(&amp;data,<span class="keyword">sizeof</span>(data));</div><div class="line">}</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>True if there is a payload available, false if none is </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_HandlingData_8ino-example.html#a9">GettingStarted_HandlingData.ino</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01092">1092</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a8e2eacacfba96426c192066f04054c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2eacacfba96426c192066f04054c5b">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the available payload</p>
<p>The size of data read is the fixed payload size, see <a class="el" href="classRF24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1">getPayloadSize()</a></p>
<dl class="section note"><dt>Note</dt><dd>I specifically chose 'void*' as a data type to make it easier for beginners to use. No casting needed.</dd>
<dd>
No longer boolean. Use available to determine if packets are available. Interrupt flags are now cleared during reads instead of when calling <a class="el" href="classRF24.html#a127105eb7a3b351cfe777c1cec50627a">available()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a buffer where the data should be written </td></tr>
    <tr><td class="paramname">len</td><td>Maximum number of bytes to read into the buffer</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(radio.available()){</div><div class="line">  radio.read(&amp;data,<span class="keyword">sizeof</span>(data));</div><div class="line">}</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>No return value. Use <a class="el" href="classRF24.html#a127105eb7a3b351cfe777c1cec50627a">available()</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_HandlingData_8ino-example.html#a10">GettingStarted_HandlingData.ino</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01119">1119</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a4cd4c198a47704db20b6b5cf0731cd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd4c198a47704db20b6b5cf0731cd58">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Be sure to call <a class="el" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe()</a> first to set the destination of where to write to.</p>
<p>This blocks until the message is successfully acknowledged by the receiver or the timeout/retransmit maxima are reached. In the current configuration, the max delay here is 60-70ms.</p>
<p>The maximum size of data written is the fixed payload size, see <a class="el" href="classRF24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1">getPayloadSize()</a>. However, you can write less, and the remainder will just be filled with zeroes.</p>
<p>TX/RX/RT interrupt flags will be cleared every time write is called</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">radio.stopListening();</div><div class="line">radio.write(&amp;data,<span class="keyword">sizeof</span>(data));</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>True if the payload was delivered successfully false if not </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_HandlingData_8ino-example.html#a8">GettingStarted_HandlingData.ino</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00863">863</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="af2e409e62d49a23e372a70b904ae30e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e409e62d49a23e372a70b904ae30e1">&#9670;&nbsp;</a></span>openWritingPipe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openWritingPipe </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>New: Open a pipe for writing via byte array. Old addressing format retained for compatibility.</p>
<p>Only one writing pipe can be open at once, but you can change the address you'll write to. Call <a class="el" href="classRF24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening()</a> first.</p>
<p>Addresses are assigned via a byte array, default is 5 byte address length s * </p><div class="fragment"><div class="line">uint8_t addresses[][6] = {<span class="stringliteral">&quot;1Node&quot;</span>,<span class="stringliteral">&quot;2Node&quot;</span>};</div><div class="line">radio.openWritingPipe(addresses[0]);</div></div><!-- fragment --> <div class="fragment"><div class="line">uint8_t address[] = { 0xCC,0xCE,0xCC,0xCE,0xCC };</div><div class="line">radio.openWritingPipe(address);</div><div class="line">address[0] = 0x33;</div><div class="line">radio.openReadingPipe(1,address);</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24.html#ad5aea7f9a3bd9c7d357fb296ce751f21">setAddressWidth</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the pipe to open. Coordinate these pipe addresses amongst nodes on the network. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_HandlingData_8ino-example.html#a4">GettingStarted_HandlingData.ino</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01160">1160</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a9edc910ccc1ffcff56814b08faca5535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edc910ccc1ffcff56814b08faca5535">&#9670;&nbsp;</a></span>openReadingPipe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openReadingPipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a pipe for reading</p>
<p>Up to 6 pipes can be open for reading at once. Open all the required reading pipes, and then call <a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe</a> </dd>
<dd>
<a class="el" href="classRF24.html#ad5aea7f9a3bd9c7d357fb296ce751f21">setAddressWidth</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Pipes 0 and 1 will store a full 5-byte address. Pipes 2-5 will technically only store a single byte, borrowing up to 4 additional bytes from pipe #1 per the assigned address width. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pipes 1-5 should share the same address, except the first byte. Only the first byte in the array should be unique, e.g. <div class="fragment"><div class="line">uint8_t addresses[][6] = {<span class="stringliteral">&quot;1Node&quot;</span>,<span class="stringliteral">&quot;2Node&quot;</span>};</div><div class="line"><a class="code" href="classRF24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(1,addresses[0]);</div><div class="line"><a class="code" href="classRF24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(2,addresses[1]);</div></div><!-- fragment --></dd>
<dd>
Pipe 0 is also used by the writing pipe. So if you open pipe 0 for reading, and then <a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a>, it will overwrite the writing pipe. Ergo, do an <a class="el" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe()</a> again before <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Which pipe# to open, 0-5. </td></tr>
    <tr><td class="paramname">address</td><td>The 24, 32 or 40 bit address of the pipe to open. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_HandlingData_8ino-example.html#a5">GettingStarted_HandlingData.ino</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01225">1225</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="adc95213ed4c8569a90eb33122e16cea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc95213ed4c8569a90eb33122e16cea6">&#9670;&nbsp;</a></span>printDetails()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::printDetails </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a giant block of debugging information to stdout</p>
<dl class="section warning"><dt>Warning</dt><dd>Does nothing if stdout is not defined. See fdevopen in stdio.h The <a class="el" href="printf_8h.html">printf.h</a> file is included with the library for Arduino. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="printf_8h.html">printf.h</a>&gt;</span></div><div class="line">setup(){</div><div class="line"> Serial.begin(115200);</div><div class="line"> <a class="code" href="printf_8h.html#afc0d9ca32710dff550ebe56ab6b39d23">printf_begin</a>();</div><div class="line"> ...</div><div class="line">}</div></div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00530">530</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="ace7dd139fabc16b77cb8325faa07620f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7dd139fabc16b77cb8325faa07620f">&#9670;&nbsp;</a></span>available() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::available </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pipe_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether there are bytes available to be read in the FIFO buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pipe_num</td><td>Which pipe has the payload available</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">uint8_t pipeNum;</div><div class="line"><span class="keywordflow">if</span>(radio.available(&amp;pipeNum)){</div><div class="line">  radio.read(&amp;data,<span class="keyword">sizeof</span>(data));</div><div class="line">  Serial.print(<span class="stringliteral">&quot;Got data on pipe&quot;</span>);</div><div class="line">  Serial.println(pipeNum);</div><div class="line">}</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>True if there is a payload available, false if none is </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01099">1099</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="ad22e44fe1a68747872fcb304a407fd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22e44fe1a68747872fcb304a407fd30">&#9670;&nbsp;</a></span>rxFifoFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::rxFifoFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the radio needs to be read. Can be used to prevent data loss </p><dl class="section return"><dt>Returns</dt><dd>True if all three 32-byte radio buffers are full </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00988">988</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="aa0a51923a09ba4f3478aba9be0f8a6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a51923a09ba4f3478aba9be0f8a6a1">&#9670;&nbsp;</a></span>powerDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::powerDown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enter low-power mode</p>
<p>To return to normal power mode, call <a class="el" href="classRF24.html#a5cdaf47aa0edd6dca1b9a8bb7972a1a3">powerUp()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>After calling <a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a>, a basic radio will consume about 13.5mA at max PA level. During active transmission, the radio will consume about 11.5mA, but this will be reduced to 26uA (.026mA) between sending. In full powerDown mode, the radio will consume approximately 900nA (.0009mA)</dd></dl>
<div class="fragment"><div class="line">radio.powerDown();</div><div class="line">avr_enter_sleep_mode(); <span class="comment">// Custom function to sleep the device</span></div><div class="line">radio.powerUp();</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00787">787</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a5cdaf47aa0edd6dca1b9a8bb7972a1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdaf47aa0edd6dca1b9a8bb7972a1a3">&#9670;&nbsp;</a></span>powerUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::powerUp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leave low-power mode - required for normal radio operation after calling <a class="el" href="classRF24.html#aa0a51923a09ba4f3478aba9be0f8a6a1">powerDown()</a></p>
<p>To return to low power mode, call <a class="el" href="classRF24.html#aa0a51923a09ba4f3478aba9be0f8a6a1">powerDown()</a>. </p><dl class="section note"><dt>Note</dt><dd>This will take up to 5ms for maximum compatibility </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00796">796</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a23bfe6502d74bb5bbccb3a7f2ba2b5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bfe6502d74bb5bbccb3a7f2ba2b5ea">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multicast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write for single NOACK writes. Optionally disables acknowledgements/autoretries for a single write.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> must be called to enable this feature</dd></dl>
<p>Can be used with <a class="el" href="classRF24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload()</a> to request a response </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> </dd>
<dd>
<a class="el" href="classRF24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK (0), NOACK (1) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00827">827</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a47b2516993481b58e724d1274a7fd9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b2516993481b58e724d1274a7fd9cb">&#9670;&nbsp;</a></span>writeFast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::writeFast </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will not block until the 3 FIFO buffers are filled with data. Once the FIFOs are full, writeFast will simply wait for success or timeout, and return 1 or 0 respectively. From a user perspective, just keep trying to send the same data. The library will keep auto retrying the current payload using the built in functionality. </p><dl class="section warning"><dt>Warning</dt><dd>It is important to never keep the nRF24L01 in TX mode and FIFO full for more than 4ms at a time. If the auto retransmit is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO to clear by issuing <a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> or ensure appropriate time between transmissions.</dd></dl>
<div class="fragment"><div class="line">Example (Partial blocking):</div><div class="line"></div><div class="line">        radio.<a class="code" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a>(&amp;buf,32);  <span class="comment">// Writes 1 payload to the buffers</span></div><div class="line">        <a class="code" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>();               <span class="comment">// Returns 0 if failed. 1 if success. Blocks only until MAX_RT timeout or success. Data flushed on fail.</span></div><div class="line"></div><div class="line">        radio.writeFast(&amp;buf,32);  <span class="comment">// Writes 1 payload to the buffers</span></div><div class="line">        <a class="code" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>(1000);           <span class="comment">// Using extended timeouts, returns 1 if success. Retries failed payloads for 1 seconds before returning 0.</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="classRF24.html#ae6fd8d5ee490d54ae1cb2e8fefee535f">writeBlocking()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the payload was delivered successfully false if not </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00946">946</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="ad16d53de0327c0b41d170cbda4bf41af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16d53de0327c0b41d170cbda4bf41af">&#9670;&nbsp;</a></span>writeFast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::writeFast </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multicast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>WriteFast for single NOACK writes. Disables acknowledgements/autoretries for a single write.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> must be called to enable this feature </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> </dd>
<dd>
<a class="el" href="classRF24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK (0) or NOACK (1) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00912">912</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="ae6fd8d5ee490d54ae1cb2e8fefee535f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fd8d5ee490d54ae1cb2e8fefee535f">&#9670;&nbsp;</a></span>writeBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::writeBlocking </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function extends the auto-retry mechanism to any specified duration. It will not block until the 3 FIFO buffers are filled with data. If so the library will auto retry until a new payload is written or the user specified timeout period is reached. </p><dl class="section warning"><dt>Warning</dt><dd>It is important to never keep the nRF24L01 in TX mode and FIFO full for more than 4ms at a time. If the auto retransmit is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO to clear by issuing <a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> or ensure appropriate time between transmissions.</dd></dl>
<div class="fragment"><div class="line">Example (Full blocking):</div><div class="line"></div><div class="line">        radio.<a class="code" href="classRF24.html#ae6fd8d5ee490d54ae1cb2e8fefee535f">writeBlocking</a>(&amp;buf,32,1000); <span class="comment">//Wait up to 1 second to write 1 payload to the buffers</span></div><div class="line">        <a class="code" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>(1000);                   <span class="comment">//Wait up to 1 second for the payload to send. Return 1 if ok, 0 if failed.</span></div><div class="line">                                           <span class="comment">//Blocks only until user timeout or success. Data flushed on fail.</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>If used from within an interrupt, the interrupt should be disabled until completion, and sei(); called to enable <a class="el" href="group__Porting__General.html#gad5b3ec1ce839fa1c4337a7d0312e9749">millis()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">timeout</td><td>User defined timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the payload was loaded into the buffer successfully false if not </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00869">869</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a12cc453453c94969d4d3f0edb3778c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12cc453453c94969d4d3f0edb3778c83">&#9670;&nbsp;</a></span>txStandBy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::txStandBy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called as soon as transmission is finished to drop the radio back to STANDBY-I mode. If not issued, the radio will remain in STANDBY-II mode which, per the data sheet, is not a recommended operating mode.</p>
<dl class="section note"><dt>Note</dt><dd>When transmitting data in rapid succession, it is still recommended by the manufacturer to drop the radio out of TX or STANDBY-II mode if there is time enough between sends for the FIFOs to empty. This is not required if auto-ack is enabled.</dd></dl>
<p>Relies on built-in auto retry functionality.</p>
<div class="fragment"><div class="line">Example (Partial blocking):</div><div class="line"></div><div class="line">        radio.<a class="code" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a>(&amp;buf,32);</div><div class="line">        radio.writeFast(&amp;buf,32);</div><div class="line">        radio.writeFast(&amp;buf,32);  <span class="comment">//Fills the FIFO buffers up</span></div><div class="line">        <span class="keywordtype">bool</span> ok = <a class="code" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>();     <span class="comment">//Returns 0 if failed. 1 if success.</span></div><div class="line">                                   <span class="comment">//Blocks only until MAX_RT timeout or success. Data flushed on fail.</span></div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>txStandBy(unsigned long timeout) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if transmission is successful </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00993">993</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="ab7f54decbe9d06cb026a5d3dfb505116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f54decbe9d06cb026a5d3dfb505116">&#9670;&nbsp;</a></span>txStandBy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::txStandBy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startTx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function allows extended blocking and auto-retries per a user defined timeout </p><div class="fragment"><div class="line">Fully Blocking Example:</div><div class="line"></div><div class="line">     radio.writeFast(&amp;buf,32);</div><div class="line">     radio.writeFast(&amp;buf,32);</div><div class="line">     radio.writeFast(&amp;buf,32);   <span class="comment">//Fills the FIFO buffers up</span></div><div class="line">     <span class="keywordtype">bool</span> ok = <a class="code" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>(1000);  <span class="comment">//Returns 0 if failed after 1 second of retries. 1 if success.</span></div><div class="line">                                 <span class="comment">//Blocks only until user defined timeout or success. Data flushed on fail.</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>If used from within an interrupt, the interrupt should be disabled until completion, and sei(); called to enable <a class="el" href="group__Porting__General.html#gad5b3ec1ce839fa1c4337a7d0312e9749">millis()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Number of milliseconds to retry failed payloads </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if transmission is successful </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01021">1021</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a65619238c25036c3de72dc2c1a1c6e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65619238c25036c3de72dc2c1a1c6e52">&#9670;&nbsp;</a></span>writeAckPayload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::writeAckPayload </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write an ack payload for the specified pipe</p>
<p>The next time a message is received on <code>pipe</code>, the data in <code>buf</code> will be sent back in the acknowledgement. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a443888504975d7441d6452a09d09a8fa">enableDynamicPayloads()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Only three of these can be pending at any time as there are only 3 FIFO buffers.<br />
 Dynamic payloads must be enabled. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Ack payloads are handled automatically by the radio chip when a payload is received. Users should generally write an ack payload as soon as <a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a> is called, so one is available when a regular payload is received. </dd>
<dd>
Ack payloads are dynamic payloads. This only works on pipes 0&amp;1 by default. Call <a class="el" href="classRF24.html#a443888504975d7441d6452a09d09a8fa">enableDynamicPayloads()</a> to enable on all pipes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipe# (typically 1-5) will get this response. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to data that is sent </td></tr>
    <tr><td class="paramname">len</td><td>Length of the data to send, up to 32 bytes max. Not affected by the static payload set by <a class="el" href="classRF24.html#a343e5d23477181011dea030fafb1954f">setPayloadSize()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01346">1346</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a30c2736fd0df9c8128cef408c8b88e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c2736fd0df9c8128cef408c8b88e92">&#9670;&nbsp;</a></span>isAckPayloadAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::isAckPayloadAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if an ack payload was received in the most recent call to <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>. The regular <a class="el" href="classRF24.html#a127105eb7a3b351cfe777c1cec50627a">available()</a> can also be used.</p>
<p>Call <a class="el" href="classRF24.html#a8e2eacacfba96426c192066f04054c5b">read()</a> to retrieve the ack payload.</p>
<dl class="section return"><dt>Returns</dt><dd>True if an ack payload is available. </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01377">1377</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="afb97dc4bdf4d2d84ea44060ac5b4ed89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb97dc4bdf4d2d84ea44060ac5b4ed89">&#9670;&nbsp;</a></span>whatHappened()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::whatHappened </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>tx_ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>tx_fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>rx_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call this when you get an interrupt to find out why</p>
<p>Tells you what caused the interrupt, and clears the state of interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tx_ok</td><td>The send was successful (TX_DS) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx_fail</td><td>The send failed, too many retries (MAX_RT) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_ready</td><td>There is a message waiting to be read (RX_DS) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01131">1131</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="acd19843064cb70ec23507412e519e4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd19843064cb70ec23507412e519e4ef">&#9670;&nbsp;</a></span>startFastWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::startFastWrite </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multicast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startTx</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-blocking write to the open writing pipe used for buffered writes</p>
<dl class="section note"><dt>Note</dt><dd>Optimization: This function now leaves the CE pin high, so the radio will remain in TX or STANDBY-II Mode until a <a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> command is issued. Can be used as an alternative to <a class="el" href="classRF24.html#aa27519fc289920094422033e0bbf8cf9">startWrite()</a> if writing multiple payloads at once. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is important to never keep the nRF24L01 in TX mode with FIFO full for more than 4ms at a time. If the auto retransmit/autoAck is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO to clear by issuing <a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> or ensure appropriate time between transmissions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast()</a> </dd>
<dd>
<a class="el" href="classRF24.html#aa27519fc289920094422033e0bbf8cf9">startWrite()</a> </dd>
<dd>
<a class="el" href="classRF24.html#ae6fd8d5ee490d54ae1cb2e8fefee535f">writeBlocking()</a></dd></dl>
<p>For single noAck writes see: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> </dd>
<dd>
<a class="el" href="classRF24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK (0) or NOACK (1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the payload was delivered successfully false if not </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00957">957</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="aa27519fc289920094422033e0bbf8cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27519fc289920094422033e0bbf8cf9">&#9670;&nbsp;</a></span>startWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::startWrite </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multicast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-blocking write to the open writing pipe</p>
<p>Just like <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>, but it returns immediately. To find out what happened to the send, catch the IRQ and then call <a class="el" href="classRF24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast()</a> </dd>
<dd>
<a class="el" href="classRF24.html#acd19843064cb70ec23507412e519e4ef">startFastWrite()</a> </dd>
<dd>
<a class="el" href="classRF24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened()</a></dd></dl>
<p>For single noAck writes see: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> </dd>
<dd>
<a class="el" href="classRF24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK (0) or NOACK (1) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00971">971</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="aeaf7fa54d3ab2a85ce215b4bf6ae933b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf7fa54d3ab2a85ce215b4bf6ae933b">&#9670;&nbsp;</a></span>reUseTX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::reUseTX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is mainly used internally to take advantage of the auto payload re-use functionality of the chip, but can be beneficial to users as well.</p>
<p>The function will instruct the radio to re-use the data in the FIFO buffers, and instructs the radio to re-send once the timeout limit has been reached. Used by writeFast and writeBlocking to initiate retries when a TX failure occurs. Retries are automatically initiated except with the standard <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>. This way, data is not flushed from the buffer until switching between modes.</p>
<dl class="section note"><dt>Note</dt><dd>This is to be used AFTER auto-retry fails if wanting to resend using the built-in payload reuse features. After issuing <a class="el" href="classRF24.html#aeaf7fa54d3ab2a85ce215b4bf6ae933b">reUseTX()</a>, it will keep reending the same payload forever or until a payload is written to the FIFO, or a flush_tx command is given. </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00903">903</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="adb7915b1d2661a82137573344f659e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7915b1d2661a82137573344f659e81">&#9670;&nbsp;</a></span>flush_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::flush_tx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty the transmit buffer. This is generally not required in standard operation. May be required in specific cases after <a class="el" href="classRF24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening()</a> , if operating at 250KBPS data rate.</p>
<dl class="section return"><dt>Returns</dt><dd>Current value of status register </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00343">343</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="ad0d522ccf39493510e64bf1740be790d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d522ccf39493510e64bf1740be790d">&#9670;&nbsp;</a></span>testCarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::testCarrier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether there was a carrier on the line for the previous listening period.</p>
<p>Useful to check for interference on the current channel.</p>
<dl class="section return"><dt>Returns</dt><dd>true if was carrier, false if not </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01420">1420</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a821285f3b54553f4402eb3fd0ac6d6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821285f3b54553f4402eb3fd0ac6d6c1">&#9670;&nbsp;</a></span>testRPD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::testRPD </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether a signal (carrier or otherwise) greater than or equal to -64dBm is present on the channel. Valid only on nRF24L01P (+) hardware. On nRF24L01, use <a class="el" href="classRF24.html#ad0d522ccf39493510e64bf1740be790d">testCarrier()</a>.</p>
<p>Useful to check for interference on the current channel and channel hopping strategies.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> goodSignal = radio.testRPD();</div><div class="line"><span class="keywordflow">if</span>(radio.available()){</div><div class="line">   Serial.println(goodSignal ? <span class="stringliteral">&quot;Strong signal &gt; 64dBm&quot;</span> : <span class="stringliteral">&quot;Weak signal &lt; 64dBm&quot;</span> );</div><div class="line">   radio.read(0,0);</div><div class="line">}</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>true if signal =&gt; -64dBm, false if not </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01427">1427</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a35e5f1533b7753806c42b76e782d917e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e5f1533b7753806c42b76e782d917e">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether this is a real radio, or a mock shim for debugging. Setting either pin to 0xff is the way to indicate that this is not a real radio.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this is a legitimate radio </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8h_source.html#l00648">648</a> of file <a class="el" href="RF24_8h_source.html">RF24.h</a>.</p>

</div>
</div>
<a id="a9944d93994a80037e3586f340f5e0107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9944d93994a80037e3586f340f5e0107">&#9670;&nbsp;</a></span>closeReadingPipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::closeReadingPipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a pipe after it has been previously opened. Can be safely called without having previously opened a pipe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipe # to close, 0-5. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01253">1253</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="ad5aea7f9a3bd9c7d357fb296ce751f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5aea7f9a3bd9c7d357fb296ce751f21">&#9670;&nbsp;</a></span>setAddressWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setAddressWidth </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>a_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the address width from 3 to 5 bytes (24, 32 or 40 bit)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_width</td><td>The address width to use: 3,4 or 5 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01211">1211</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a4c6d3959c8320e64568395f4ef507aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6d3959c8320e64568395f4ef507aef">&#9670;&nbsp;</a></span>setRetries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setRetries </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the number and delay of retries upon failed submit</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>How long to wait between each retry, in multiples of 250us, max is 15. 0 means 250us, 15 means 4000us. </td></tr>
    <tr><td class="paramname">count</td><td>How many retries before giving up, max 15 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01586">1586</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a5e6e5a5f6c85d2638381cab2c0f3702e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6e5a5f6c85d2638381cab2c0f3702e">&#9670;&nbsp;</a></span>setChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set RF communication channel</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Which RF channel to communicate on, 0-125 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00455">455</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a6a66a94609309e17edaa1919e66cea0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a66a94609309e17edaa1919e66cea0a">&#9670;&nbsp;</a></span>getChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getChannel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get RF communication channel</p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured RF Channel </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00461">461</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a343e5d23477181011dea030fafb1954f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343e5d23477181011dea030fafb1954f">&#9670;&nbsp;</a></span>setPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setPayloadSize </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Static Payload Size</p>
<p>This implementation uses a pre-stablished fixed payload size for all transmissions. If this method is never called, the driver will always transmit the maximum payload size (32 bytes), no matter how much was sent to <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of bytes in the payload </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00468">468</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a0aa0c7cbe3d38fef4722f3f1d2d6c5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1">&#9670;&nbsp;</a></span>getPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getPayloadSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Static Payload Size</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24.html#a343e5d23477181011dea030fafb1954f">setPayloadSize()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the payload </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00475">475</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a65963ed8d8fd45f847e2f673995b85e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65963ed8d8fd45f847e2f673995b85e1">&#9670;&nbsp;</a></span>getDynamicPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getDynamicPayloadSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Dynamic Payload Size</p>
<p>For dynamic payloads, this pulls the size of the payload off the chip</p>
<dl class="section note"><dt>Note</dt><dd>Corrupt packets are now detected and flushed per the manufacturer. <div class="fragment"><div class="line"><span class="keywordflow">if</span>(radio.available()){</div><div class="line">  <span class="keywordflow">if</span>(radio.getDynamicPayloadSize() &lt; 1){</div><div class="line">    <span class="comment">// Corrupt payload has been flushed</span></div><div class="line">    <span class="keywordflow">return</span>; </div><div class="line">  }</div><div class="line">  radio.read(&amp;data,<span class="keyword">sizeof</span>(data));</div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Payload length of last-received dynamic payload </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01068">1068</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="abf8efced2ee9edbcc6510878b20edc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8efced2ee9edbcc6510878b20edc1b">&#9670;&nbsp;</a></span>enableAckPayload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::enableAckPayload </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable custom payloads on the acknowledge packets</p>
<p>Ack payloads are a handy way to return data back to senders without manually changing the radio modes on both units.</p>
<dl class="section note"><dt>Note</dt><dd>Ack payloads are dynamic payloads. This only works on pipes 0&amp;1 by default. Call <a class="el" href="classRF24.html#a443888504975d7441d6452a09d09a8fa">enableDynamicPayloads()</a> to enable on all pipes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01311">1311</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a443888504975d7441d6452a09d09a8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443888504975d7441d6452a09d09a8fa">&#9670;&nbsp;</a></span>enableDynamicPayloads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::enableDynamicPayloads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable dynamically-sized payloads</p>
<p>This way you don't always have to send large packets just to send them once in a while. This enables dynamic payloads on ALL pipes. </p>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01270">1270</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a486c4c47a6973614ae595ae96f221165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486c4c47a6973614ae595ae96f221165">&#9670;&nbsp;</a></span>disableDynamicPayloads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::disableDynamicPayloads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable dynamically-sized payloads</p>
<p>This disables dynamic payloads on ALL pipes. Since Ack Payloads requires Dynamic Payloads, Ack Payloads are also disabled. If dynamic payloads are later re-enabled and ack payloads are desired then <a class="el" href="classRF24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload()</a> must be called again as well. </p>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01290">1290</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a6253607ac2a1995af91a35cea6899c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6253607ac2a1995af91a35cea6899c31">&#9670;&nbsp;</a></span>enableDynamicAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::enableDynamicAck </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable dynamic ACKs (single write multicast or unicast) for chosen messages</p>
<dl class="section note"><dt>Note</dt><dd>To enable full multicast or per-pipe multicast, use <a class="el" href="classRF24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This MUST be called prior to attempting single write NOACK calls <div class="fragment"><div class="line">radio.enableDynamicAck();</div><div class="line">radio.write(&amp;data,32,1);  <span class="comment">// Sends a payload with no acknowledgement requested</span></div><div class="line">radio.write(&amp;data,32,0);  <span class="comment">// Sends a payload using auto-retry/autoACK</span></div></div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01332">1332</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a62846750b82682beb7593719eb60ed60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62846750b82682beb7593719eb60ed60">&#9670;&nbsp;</a></span>isPVariant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::isPVariant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether the hardware is an nRF24L01+ or not.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the hardware is nRF24L01+ (or compatible) and false if its not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01384">1384</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="aec71746d59da978bcbb975167886a2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec71746d59da978bcbb975167886a2cc">&#9670;&nbsp;</a></span>setAutoAck() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setAutoAck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable auto-acknowlede packets</p>
<p>This is enabled by default, so it's only needed if you want to turn it off for some reason.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Whether to enable (true) or disable (false) auto-acks </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01391">1391</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a60dba9e558f3620ab489af68ea3dea9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dba9e558f3620ab489af68ea3dea9c">&#9670;&nbsp;</a></span>setAutoAck() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setAutoAck </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable auto-acknowlede packets on a per pipeline basis.</p>
<p>AA is enabled by default, so it's only needed if you want to turn it off/on for some reason on a per pipeline basis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipeline to modify </td></tr>
    <tr><td class="paramname">enable</td><td>Whether to enable (true) or disable (false) auto-acks </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01401">1401</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="adedac579590a668ae97baccab284de8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedac579590a668ae97baccab284de8a">&#9670;&nbsp;</a></span>setPALevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setPALevel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Power Amplifier (PA) level to one of four levels: RF24_PA_MIN, RF24_PA_LOW, RF24_PA_HIGH and RF24_PA_MAX</p>
<p>The power levels correspond to the following output levels respectively: NRF24L01: -18dBm, -12dBm,-6dBM, and 0dBm</p>
<p>SI24R1: -6dBm, 0dBm, 3dBM, and 7dBm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Desired PA level. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_HandlingData_8ino-example.html#a2">GettingStarted_HandlingData.ino</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01434">1434</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="af7c4dcd84466168c5816382ceb366067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c4dcd84466168c5816382ceb366067">&#9670;&nbsp;</a></span>getPALevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getPALevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches the current PA level.</p>
<p>NRF24L01: -18dBm, -12dBm, -6dBm and 0dBm SI24R1: -6dBm, 0dBm, 3dBm, 7dBm</p>
<dl class="section return"><dt>Returns</dt><dd>Returns values 0 to 3 representing the PA Level. </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01451">1451</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="aeb9920e7a95699748b003c4a839b0814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9920e7a95699748b003c4a839b0814">&#9670;&nbsp;</a></span>setDataRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::setDataRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="RF24_8h.html#a82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a>&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the transmission data rate</p>
<dl class="section warning"><dt>Warning</dt><dd>setting RF24_250KBPS will fail for non-plus units</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>RF24_250KBPS for 250kbs, RF24_1MBPS for 1Mbps, or RF24_2MBPS for 2Mbps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the change was successful </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01459">1459</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a72a7b11dafe8ffab6135f243decce0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a7b11dafe8ffab6135f243decce0d7">&#9670;&nbsp;</a></span>getDataRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RF24_8h.html#a82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a> RF24::getDataRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches the transmission data rate</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hardware's currently configured datarate. The value is one of 250kbs, RF24_1MBPS for 1Mbps, or RF24_2MBPS, as defined in the rf24_datarate_e enum. </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01509">1509</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a89f626fc4a58dd997153bcc0f8198b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f626fc4a58dd997153bcc0f8198b9e">&#9670;&nbsp;</a></span>setCRCLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setCRCLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="RF24_8h.html#adbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a>&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the CRC length <br />
CRC checking cannot be disabled if auto-ack is enabled </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>RF24_CRC_8 for 8-bit or RF24_CRC_16 for 16-bit </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01536">1536</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="aba4ca91b829afcd94a4c11e0343e3796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4ca91b829afcd94a4c11e0343e3796">&#9670;&nbsp;</a></span>getCRCLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RF24_8h.html#adbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a> RF24::getCRCLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the CRC length <br />
CRC checking cannot be disabled if auto-ack is enabled </p><dl class="section return"><dt>Returns</dt><dd>RF24_CRC_DISABLED if disabled or RF24_CRC_8 for 8-bit or RF24_CRC_16 for 16-bit </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01559">1559</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a5eacd9ecfbc19864801d714c292cf8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eacd9ecfbc19864801d714c292cf8be">&#9670;&nbsp;</a></span>disableCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::disableCRC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable CRC validation</p>
<dl class="section warning"><dt>Warning</dt><dd>CRC cannot be disabled if auto-ack/ESB is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01579">1579</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="abf68b9b0c9cd17179e9e144c3e7f9c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf68b9b0c9cd17179e9e144c3e7f9c45">&#9670;&nbsp;</a></span>maskIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::maskIRQ </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tx_ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tx_fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rx_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The radio will generate interrupt signals when a transmission is complete, a transmission fails, or a payload is received. This allows users to mask those interrupts to prevent them from generating a signal on the interrupt pin. Interrupts are enabled on the radio chip by default.</p>
<div class="fragment"><div class="line">Mask all interrupts except the receive interrupt:</div><div class="line"></div><div class="line">radio.maskIRQ(1,1,0);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx_ok</td><td>Mask transmission complete interrupts </td></tr>
    <tr><td class="paramname">tx_fail</td><td>Mask transmit failure interrupts </td></tr>
    <tr><td class="paramname">rx_ready</td><td>Mask payload received interrupts </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01056">1056</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="aa7e8523f86f9f8f20c274e0c89a5fd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e8523f86f9f8f20c274e0c89a5fd45">&#9670;&nbsp;</a></span>openReadingPipe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openReadingPipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a pipe for reading </p><dl class="section note"><dt>Note</dt><dd>For compatibility with old code only, see new function</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pipes 1-5 should share the first 32 bits. Only the least significant byte should be unique, e.g. <div class="fragment"><div class="line"><a class="code" href="classRF24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(1,0xF0F0F0F0AA);</div><div class="line"><a class="code" href="classRF24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(2,0xF0F0F0F066);</div></div><!-- fragment --></dd>
<dd>
Pipe 0 is also used by the writing pipe. So if you open pipe 0 for reading, and then <a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a>, it will overwrite the writing pipe. Ergo, do an <a class="el" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe()</a> again before <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Which pipe# to open, 0-5. </td></tr>
    <tr><td class="paramname">address</td><td>The 40-bit address of the pipe to open. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01184">1184</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a50c8e68ee840e1860a31dbdc83afbd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c8e68ee840e1860a31dbdc83afbd77">&#9670;&nbsp;</a></span>openWritingPipe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openWritingPipe </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a pipe for writing </p><dl class="section note"><dt>Note</dt><dd>For compatibility with old code only, see new function</dd></dl>
<p>Addresses are 40-bit hex values, e.g.:</p>
<div class="fragment"><div class="line"><a class="code" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe</a>(0xF0F0F0F0F0);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The 40-bit address of the pipe to open. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l01145">1145</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<a id="a575c061519e7820e1850ad380c617d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575c061519e7820e1850ad380c617d95">&#9670;&nbsp;</a></span>flush_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::flush_rx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty the receive buffer</p>
<dl class="section return"><dt>Returns</dt><dd>Current value of status register </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8cpp_source.html#l00336">336</a> of file <a class="el" href="RF24_8cpp_source.html">RF24.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2e40fe66d1231a333aa2534e8491f828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e40fe66d1231a333aa2534e8491f828">&#9670;&nbsp;</a></span>failureDetected</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::failureDetected</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable error detection by un-commenting #define FAILURE_HANDLING in <a class="el" href="RF24__config_8h.html">RF24_config.h</a> If a failure has been detected, it usually indicates a hardware issue. By default the library will cease operation when a failure is detected. This should allow advanced users to detect and resolve intermittent hardware issues.</p>
<p>In most cases, the radio must be re-enabled via radio.begin(); and the appropriate settings applied after a failure occurs, if wanting to re-enable the device immediately.</p>
<p>Usage: (Failure handling must be enabled per above) </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(radio.failureDetected){ </div><div class="line">  radio.begin();                       <span class="comment">// Attempt to re-configure the radio with defaults</span></div><div class="line">  radio.failureDetected = 0;           <span class="comment">// Reset the detection value</span></div><div class="line">  radio.openWritingPipe(addresses[1]); <span class="comment">// Re-configure pipe addresses</span></div><div class="line">  radio.openReadingPipe(1,addresses[0]);</div><div class="line">  report_failure();                    <span class="comment">// Blink leds, send a message, etc. to indicate failure</span></div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RF24_8h_source.html#l00678">678</a> of file <a class="el" href="RF24_8h_source.html">RF24.h</a>.</p>

</div>
</div>
<a id="a958fb99f54415101ca008ab11b3bfe79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958fb99f54415101ca008ab11b3bfe79">&#9670;&nbsp;</a></span>txDelay</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RF24::txDelay</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The driver will delay for this duration when <a class="el" href="classRF24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening()</a> is called</p>
<p>When responding to payloads, faster devices like ARM(RPi) are much faster than Arduino:</p><ol type="1">
<li>Arduino sends data to RPi, switches to RX mode</li>
<li>The RPi receives the data, switches to TX mode and sends before the Arduino radio is in RX mode</li>
<li>If AutoACK is disabled, this can be set as low as 0. If AA/ESB enabled, set to 100uS minimum on RPi</li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd>If set to 0, ensure 130uS delay after <a class="el" href="classRF24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening()</a> and before any sends </dd></dl>

<p class="definition">Definition at line <a class="el" href="RF24_8h_source.html#l00936">936</a> of file <a class="el" href="RF24_8h_source.html">RF24.h</a>.</p>

</div>
</div>
<a id="ad08121bf844f08dbe53f51576b7c4066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08121bf844f08dbe53f51576b7c4066">&#9670;&nbsp;</a></span>csDelay</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RF24::csDelay</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>On all devices but Linux and ATTiny, a small delay is added to the CSN toggling function</p>
<p>This is intended to minimise the speed of SPI polling due to radio commands</p>
<p>If using interrupts or timed requests, this can be set to 0 Default:5 </p>

<p class="definition">Definition at line <a class="el" href="RF24_8h_source.html#l00947">947</a> of file <a class="el" href="RF24_8h_source.html">RF24.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="RF24_8h_source.html">RF24.h</a></li>
<li><a class="el" href="RF24_8cpp_source.html">RF24.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 21 2019 22:41:10 for Optimized High Speed NRF24L01+ Driver Class Documenation by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
